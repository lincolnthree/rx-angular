{"version":3,"sources":["./node_modules/util/support/isBufferBrowser.js","./node_modules/templateAlpha0/__ivy_ngcc__/fesm2015/rx-angular-template.js","./node_modules/util/node_modules/inherits/inherits_browser.js","./node_modules/util/util.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyJ;AAC/B;AAC1F;AAC2G;AAC5F;;AAEP;AACxC;AACA;AACA,uBAAuB,+CAAE,MAAM,iDAAI;AACnC;;AAEA;AACA;AACA,uBAAuB,2EAAoB,IAAI,0DAAG;AAClD;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAa;AAC3C,yCAAyC,2EAAoB,IAAI,gEAAS;AAC1E,UAAU,+CAAE;AACZ;AACA,yCAAyC,kDAAa;AACtD,8DAA8D,2EAAoB;AAClF;AACA;AACA;AACA,IAAI,0DAAG;AACP;AACA,mBAAmB,+CAAE;AACrB;AACA;AACA;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,6DAAM,0BAA0B,gEAAS,eAAe,2EAAoB,IAAI,0DAAG,wBAAwB,qEAAc,aAAa,0DAAG,sCAAsC,iEAAU;AAC7L;AACA,eAAe,0CAAK;AACpB,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iDAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,2BAA2B,mBAAmB;AAC9C;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,IAAI;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,CAAC;AACD;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA;AACA;AACA,WAAW,OAAO;AAClB,iBAAiB,iCAAiC;AAClD,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU;AACjC,yCAAyC,iDAAY;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,0DAAG;AAC5C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,iDAAI;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb,6BAA6B,iDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAc;AACjC,SAAS;AACT,mCAAmC;AACnC,gBAAgB,qDAAQ;AACxB,uBAAuB,mDAAc;AACrC;AACA,oDAAoD,aAAa,WAAW;AAC5E;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;AACb,yBAAyB,iDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAc;AAC7B,KAAK;AACL;AACA;AACA,mBAAmB,mDAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B,+CAAU;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;AAEjD;AACA,oBAAoB,4DAAuB;AAC3C,aAAa,kDAAa;AAC1B,iBAAiB,mDAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;;AAEA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD;AACvD,6BAA6B,iDAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAU;AAC3C,QAAQ,iDAAI;AACZ;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAU;AAC3C,QAAQ,iDAAI;AACZ;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAU;AAC3C,QAAQ,iDAAI;AACZ;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,+BAA+B,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,mEAAmE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oDAAoD,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mDAAmD,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B,2EAAoC,IAAI;AAClH,iBAAiB,0DAAmB,EAAE,4CAA4C;AAClF;AACA,KAAK,OAAO,+DAAiB;AAC7B;AACA,WAAW,wDAAU,GAAG,wDAAU,uBAAuB,+DAAiB;AAC1E;;AAEA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF,kBAAkB,8DAAuB,EAAE,mBAAmB;AAC9D,kBAAkB,8DAAuB,EAAE,gBAAgB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,CAAC,+DAAwB,GAAG,+DAAwB,CAAC,yDAAkB,GAAG,+DAAwB,CAAC,8DAAuB,GAAG;AAC3O,oBAAoB,+DAAwB,EAAE,8DAA8D,0DAA0D,EAAE;AACxK;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,yDAAW,EAAE;AACzB,KAAK,OAAO,8DAAgB;AAC5B;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,eAAe,wDAAU,GAAG,wDAAU,uBAAuB,+DAAiB;AAC9E,QAAQ,yDAAW;AACnB,QAAQ,8DAAgB;AACxB;;AAEA;AACA;AACA;AACA,gDAAgD,+BAA+B;AAC/E,iBAAiB,8DAAuB,EAAE,kBAAkB;AAC5D,iBAAiB,8DAAuB,GAAG;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAY;AAC5C,2BAA2B,oDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAG;AACrB;AACA;AACA;AACA,0EAA0E,0CAA0C,+DAAwB,CAAC,wDAAiB,GAAG;AACjK,8BAA8B,+DAAwB,EAAE,0EAA0E,gCAAgC,EAAE;AACpK;AACA,KAAK,OAAO,wDAAU;AACtB;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,yBAAyB,wDAAU,GAAG,wDAAU,uBAAuB,wDAAU;AACjF;;AAEA;AACA;AACA;AACA,oEAAoE,yCAAyC;AAC7G,2BAA2B,8DAAuB,EAAE,4BAA4B;AAChF,2BAA2B,8DAAuB,GAAG;;AAErD;AACA;AACA,0DAA0D,oCAAoC;AAC9F,sBAAsB,8DAAuB,EAAE,uBAAuB;AACtE,sBAAsB,8DAAuB,EAAE,wDAAwD;AACvG,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,kDAAI;AAClB,gBAAgB,4BAA4B;AAC5C,KAAK,gBAAgB,UAAU,OAAO,+DAAwB,EAAE,EAAE,EAAE,QAAQ,EAAE;AAC9E,cAAc,oDAAoD,gEAAyB,cAAc,gDAAgD,EAAE,EAAE;AAC7J,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,sDAAQ;AACtB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;AACtB,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,uDAAS;AACvB,gBAAgB,sBAAsB;AACtC,KAAK,gBAAgB,UAAU,OAAO,+DAAwB,EAAE,GAAG,OAAO,yDAAkB,EAAE,GAAG,OAAO,8DAAuB,EAAE,EAAE,EAAE,GAAG;AACxI,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB;AACA,SAAS,GAAG,EAAE,EAAE;AAChB,cAAc,oDAAoD,gEAAyB,aAAa,wDAAwD,EAAE,EAAE;AACpK,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,sDAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;AACtB,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,uDAAS;AACvB,gBAAgB,wBAAwB;AACxC,KAAK,gBAAgB,UAAU,OAAO,wDAAiB,EAAE,EAAE,EAAE,GAAG;AAChE,kBAAkB,mDAAK;AACvB;AACA,SAAS,GAAG,EAAE,EAAE;AAChB,cAAc,oDAAoD,gEAAyB,uBAAuB,4EAA4E,EAAE,EAAE;AAClM,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,sDAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;AACtB,cAAc,oDAAoD,gEAAyB,kBAAkB,wDAAwD,EAAE,EAAE;AACzK,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,sDAAQ;AACtB;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;;AAE+qB;;AAE/qB,+C;;;;;;;;;;;ACz9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,gCAAoB;;AAE/C;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,mBAAmB,mBAAO,CAAC,sBAAU;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D,2BAA2B,mDAAmD;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"default~alphas-compare-alphas-compare-module~pixel-priority-pixel-priority-module.js","sourcesContent":["module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","import { of, from, ReplaySubject, EMPTY, Subscription, Observable, asyncScheduler, animationFrameScheduler, asapScheduler, BehaviorSubject } from 'rxjs';\nimport { distinctUntilChanged, map, switchMap, filter, tap, withLatestFrom, catchError, observeOn } from 'rxjs/operators';\nimport { isObject } from 'util';\nimport { ɵmarkDirty, ChangeDetectorRef, Pipe, NgModule, TemplateRef, ViewContainerRef, Input, Directive, ElementRef } from '@angular/core';\nimport { __decorate, __metadata } from 'tslib';\n\nimport * as ɵngcc0 from '@angular/core';\nfunction toObservableValue(p) {\r\n    // @ts-ignore\r\n    return p == null ? of(p) : from(p);\r\n}\n\nfunction nameToStrategy(strategies) {\r\n    return (o$) => {\r\n        return o$.pipe(distinctUntilChanged(), map((strategy) => {\r\n            const s = strategies[strategy];\r\n            if (!!s) {\r\n                return s;\r\n            }\r\n            throw new Error(`Strategy ${strategy} does not exist.`);\r\n        }));\r\n    };\r\n}\n\n/**\r\n * RenderAware\r\n *\r\n * @description\r\n * This function returns an object that holds all the shared logic for the push pipe and the let directive\r\n * responsible for change detection\r\n * If you extend this class you need to implement how the update of the rendered value happens.\r\n * Also custom behaviour is something you need to implement in the extending class\r\n */\r\nfunction createRenderAware(cfg) {\r\n    const strategyName$ = new ReplaySubject(1);\r\n    const strategy$ = strategyName$.pipe(distinctUntilChanged(), switchMap(stringOrObservable => typeof stringOrObservable === 'string'\r\n        ? of(stringOrObservable)\r\n        : stringOrObservable), nameToStrategy(cfg.strategies));\r\n    const observablesFromTemplate$ = new ReplaySubject(1);\r\n    const valuesFromTemplate$ = observablesFromTemplate$.pipe(distinctUntilChanged());\r\n    let firstTemplateObservableChange = true;\r\n    const renderingEffect$ = valuesFromTemplate$.pipe(\r\n    // handle null | undefined assignment and new Observable reset\r\n    map(observable$ => {\r\n        if (observable$ === null) {\r\n            return of(null);\r\n        }\r\n        if (!firstTemplateObservableChange) {\r\n            cfg.resetObserver.next();\r\n            if (observable$ === undefined) {\r\n                return of(undefined);\r\n            }\r\n        }\r\n        firstTemplateObservableChange = false;\r\n        return observable$;\r\n    }), \r\n    // forward only observable values\r\n    filter(o$ => o$ !== undefined), switchMap(o$ => o$.pipe(distinctUntilChanged(), tap(cfg.updateObserver))), withLatestFrom(strategy$), tap(([v, strat]) => strat.scheduleCD()), catchError(e => {\r\n        console.error(e);\r\n        return EMPTY;\r\n    }));\r\n    return {\r\n        nextPotentialObservable(value) {\r\n            observablesFromTemplate$.next(value);\r\n        },\r\n        nextStrategy(nextConfig) {\r\n            strategyName$.next(nextConfig);\r\n        },\r\n        activeStrategy$: strategy$,\r\n        subscribe() {\r\n            return new Subscription()\r\n                .add(strategy$.subscribe())\r\n                .add(renderingEffect$.subscribe());\r\n        }\r\n    };\r\n}\n\n/**\r\n * @description\r\n *\r\n * A fallback for the new `globalThis` reference.\r\n *\r\n *  It should be used to replace `window` due to different environments in:\r\n *  - SSR (Server Side Rendering)\r\n *  - Tests\r\n *  - Browser\r\n *\r\n *  @return {globalThis} - A reference to globalThis. `window` in the Browser.\r\n */\r\nfunction getGlobalThis() {\r\n    return (globalThis || self || window);\r\n}\n\n/*\r\n * createPropertiesWeakMap\r\n *\r\n * @param getDefaults: (o: O) => P\r\n * Example:\r\n *\r\n * export interface Properties {\r\n *   isCoalescing: boolean;\r\n * }\r\n *\r\n * const obj: object = {\r\n *   foo: 'bar',\r\n *   isCoalescing: 'weakMap version'\r\n * };\r\n *\r\n * const getDefaults = (ctx: object): Properties => ({isCoalescing: false});\r\n * const propsMap = createPropertiesWeakMap<object, Properties>(getDefaults);\r\n *\r\n * console.log('obj before:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props before:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"weakMap version\"}\r\n *\r\n * propsMap.setProps(obj, {isCoalescing: true});\r\n * console.log('obj after:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props after:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"true\"}\r\n * */\r\nfunction createPropertiesWeakMap(getDefaults) {\r\n    const propertyMap = new WeakMap();\r\n    return {\r\n        getProps: getProperties,\r\n        setProps: setProperties\r\n    };\r\n    function getProperties(ctx) {\r\n        const defaults = getDefaults(ctx);\r\n        const propertiesPresent = propertyMap.get(ctx);\r\n        let properties;\r\n        if (propertiesPresent !== undefined) {\r\n            properties = propertiesPresent;\r\n        }\r\n        else {\r\n            properties = {};\r\n            Object.entries(defaults).forEach(([prop, value]) => {\r\n                properties[prop] = hasKey(ctx, prop) ? ctx[prop] : value;\r\n            });\r\n            propertyMap.set(ctx, properties);\r\n        }\r\n        return properties;\r\n    }\r\n    function setProperties(ctx, props) {\r\n        const properties = getProperties(ctx);\r\n        Object.entries(props).forEach(([prop, value]) => {\r\n            properties[prop] = value;\r\n        });\r\n        propertyMap.set(ctx, properties);\r\n        return properties;\r\n    }\r\n    function hasKey(ctx, property) {\r\n        return ctx[property] != null;\r\n    }\r\n}\n\n/**\r\n * envZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks the window object `zone.js` was instantiated.\r\n * If so, the `window` object maintains a property named `Zone`.\r\n *\r\n * Here how Angular checks it: https://github.com/angular/angular/blob/master/packages/core/src/zone/ng_zone.ts#L123\r\n *\r\n * @return {boolean} - true if `zone.js` patched global APIs.\r\n *\r\n */\r\nfunction envZonePatched() {\r\n    return getGlobalThis().Zone !== undefined;\r\n}\r\n/**\r\n * apiZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks if a specific Browser API is patched by `zone.js`.\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @return {boolean} - true if `zone.js` patched the API in question.\r\n *\r\n */\r\nfunction apiZonePatched(name) {\r\n    // if symbol is present, zone patched the API\r\n    return getGlobalThis()['__zone_symbol__' + name] !== undefined;\r\n}\r\nconst zoneDetectionCache = new WeakMap();\r\n/**\r\n * isNgZone\r\n *\r\n * @description\r\n *\r\n * This function takes an instance of a class which implements the NgZone interface and checks if\r\n * its `runOutsideAngular()` function calls `apply()` on the function passed as parameter. This\r\n * means the Angular application that instantiated this service assumes it runs in a ZoneLess\r\n * environment, and therefore it's change detection will not be triggered by zone related logic.\r\n *\r\n * However, keep in mind this does not mean `zone.js` is not present.\r\n * The environment could still run in ZoneFull mode even if Angular turned it off.\r\n * Consider the situation of a Angular element configured for ZoneLess\r\n * environments is used in an Angular application relining on the zone mechanism.\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NgZone`.\r\n * @return {boolean} - true if instance is of type `NgZone`.\r\n *\r\n */\r\nfunction isNgZone(instance) {\r\n    const cachedValue = zoneDetectionCache.get(instance);\r\n    if (cachedValue !== undefined) {\r\n        return cachedValue;\r\n    }\r\n    let calledApply = false;\r\n    function fn() { }\r\n    fn.apply = () => (calledApply = true);\r\n    instance.runOutsideAngular(fn);\r\n    zoneDetectionCache.set(instance, calledApply);\r\n    return calledApply;\r\n}\r\n/**\r\n * isNoopNgZone\r\n *\r\n *@description\r\n *\r\n * This function takes any instance of a class and checks\r\n * if the constructor name is equal to `NoopNgZone`.\r\n *\r\n * For more detailed information read the description of [isNgZone](#isngzone).\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NoopNgZone`.\r\n * @return {boolean} - true if instance is of type `NoopNgZone`.\r\n *\r\n */\r\nfunction isNoopNgZone(instance) {\r\n    return !isNgZone(instance);\r\n}\n\n/** A shared promise instance to cause a delay of one microtask */\r\nlet resolvedPromise = null;\r\nfunction getUnpatchedResolvedPromise() {\r\n    resolvedPromise =\r\n        resolvedPromise ||\r\n            (apiZonePatched('Promise')\r\n                ? getGlobalThis().__zone_symbol__Promise.resolve()\r\n                : Promise.resolve());\r\n    return resolvedPromise;\r\n}\n\n/**\r\n * envRunsIvy\r\n *\r\n * @description\r\n * Determines the used view engine of an Angular project is Ivy or not.\r\n * The check is done based on following table:\r\n * | render       | ViewEngine | ViewEngine | Ivy         | Ivy         |\r\n * | ------------ | ---------- | ---------- | ----------- | ----------- |\r\n * | **mode**     | prod       | dev        | prod        | dev         |\r\n * | **ng**       | present    | present    | `undefined` | present     |\r\n * | **ng.probe** | present    | present    | `undefined` | `undefined` |\r\n *\r\n *  So for Ivy we need to make sure that ng is undefined or,\r\n *  in case of dev environment, ng.probe is undefined.\r\n *\r\n * @return {boolean} - true if the used view engine is Ivy.\r\n *\r\n */\r\nfunction isViewEngineIvy() {\r\n    const ng = getGlobalThis().ng;\r\n    // Is the global ng object is unavailable?\r\n    // ng === undefined in Ivy production mode\r\n    // View Engine has the ng object both in development mode and production mode.\r\n    return (ng === undefined ||\r\n        // in case we are in dev mode in ivy\r\n        // `probe` property is available on ng object we use View Engine.\r\n        ng.probe === undefined);\r\n}\n\n/**\r\n * getZoneUnPatchedApi\r\n *\r\n * @description\r\n *\r\n * This function returns the zone un-patched API for the a specific Browser API.\r\n * If no element is passed the window is used instead\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @param elem {any} - The elem to get un-patched API from.\r\n * @return {Function} - The zone un-patched API in question.\r\n *\r\n */\r\nfunction getZoneUnPatchedApi(name, elem) {\r\n    elem = elem || getGlobalThis();\r\n    return apiZonePatched(name) ? elem['__zone_symbol__' + name] : elem[name];\r\n}\r\n/**\r\n *\r\n * @description\r\n *\r\n * This function takes an elem and event and re-applies the listeners from the passed event to the\r\n * passed element with the zone un-patched version of it.\r\n *\r\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\r\n * @param event {string} - The name of the event from which to re-apply the listeners.\r\n *\r\n * @returns void\r\n */\r\nfunction unpatchEventListener(elem, event) {\r\n    const eventListeners = elem.eventListeners(event);\r\n    // Return if no event listeners are present\r\n    if (!eventListeners) {\r\n        return;\r\n    }\r\n    const addEventListener = getZoneUnPatchedApi('addEventListener', elem).bind(elem);\r\n    eventListeners.forEach(listener => {\r\n        // Remove and reapply listeners with patched API\r\n        elem.removeEventListener(event, listener);\r\n        // Reapply listeners with un-patched API\r\n        addEventListener(event, listener);\r\n    });\r\n}\n\nconst ɵ0 = ctx => ({\r\n    numCoalescingSubscribers: 0\r\n});\r\nconst coalescingContextPropertiesMap = createPropertiesWeakMap(ɵ0);\r\nfunction createCoalesceManager(scope = {}) {\r\n    return {\r\n        remove: removeSubscriber,\r\n        add: addSubscription,\r\n        isCoalescing\r\n    };\r\n    // Increments the number of subscriptions in a scope e.g. a class instance\r\n    function removeSubscriber() {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers -\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Decrements the number of subscriptions in a scope e.g. a class instance\r\n    function addSubscription() {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers +\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Checks if anybody else is already coalescing atm\r\n    function isCoalescing() {\r\n        return (coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers >\r\n            0);\r\n    }\r\n}\n\n/**\r\n * @description\r\n * Limits the number of synchronous emitted a value from the source Observable to\r\n * one emitted value per\r\n *   [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats\r\n *   this process for every tick of the browsers event loop.\r\n *\r\n * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.\r\n * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope\r\n *   coalescing.\r\n *\r\n * @param {function(value: T): SubscribableOrPromise} durationSelector - A function\r\n * that receives a value from the source Observable, for computing the silencing\r\n * duration for each source value, returned as an Observable or a Promise.\r\n * It defaults to `requestAnimationFrame` as durationSelector.\r\n * @param {Object} config - A configuration object to define `leading` and `trailing` behavior and the context object.\r\n * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.\r\n * @return {Observable<T>} An Observable that performs the coalesce operation to\r\n * limit the rate of emissions from the source.\r\n *\r\n * @usageNotes\r\n * Emit clicks at a rate of at most one click per second\r\n * ```ts\r\n * import { fromEvent, animationFrames } from 'rxjs';\r\n * import { coalesce } from 'ngRx/component';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(coalesce(ev => animationFrames));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n */\r\nfunction coalesceWith(durationSelector, scope) {\r\n    const _scope = scope || {};\r\n    return source => {\r\n        const o$ = new Observable(observer => {\r\n            const rootSubscription = new Subscription();\r\n            rootSubscription.add(source.subscribe(createInnerObserver(observer, rootSubscription)));\r\n            return rootSubscription;\r\n        });\r\n        return o$;\r\n        function createInnerObserver(outerObserver, rootSubscription) {\r\n            let actionSubscription;\r\n            let latestValue;\r\n            const coa = createCoalesceManager(_scope);\r\n            const tryEmitLatestValue = () => {\r\n                coa.remove();\r\n                if (!coa.isCoalescing()) {\r\n                    outerObserver.next(latestValue);\r\n                }\r\n            };\r\n            return {\r\n                complete: () => {\r\n                    if (actionSubscription) {\r\n                        tryEmitLatestValue();\r\n                    }\r\n                    outerObserver.complete();\r\n                },\r\n                error: error => outerObserver.error(error),\r\n                next: value => {\r\n                    latestValue = value;\r\n                    if (!actionSubscription) {\r\n                        coa.add();\r\n                        actionSubscription = durationSelector.subscribe({\r\n                            next: () => {\r\n                                tryEmitLatestValue();\r\n                                actionSubscription = undefined;\r\n                            },\r\n                            complete: () => {\r\n                                if (actionSubscription) {\r\n                                    tryEmitLatestValue();\r\n                                    actionSubscription = undefined;\r\n                                }\r\n                            }\r\n                        });\r\n                        rootSubscription.add(actionSubscription);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}\n\nfunction renderChange(strategy) {\r\n    return (s) => {\r\n        return s.pipe(strategy.behavior, tap(v => strategy.renderMethod()));\r\n    };\r\n}\n\nconst unpatchedAsapScheduler = {\r\n    now() {\r\n        return 0;\r\n    },\r\n    schedule(work, options, state) {\r\n        return from(getUnpatchedResolvedPromise()).subscribe(() => work(state));\r\n    }\r\n};\n\n/**\r\n *\r\n * Implementation based on rxjs-etc => IdleScheduler\r\n *\r\n */\r\nvar PostTaskSchedulerPriority;\r\n(function (PostTaskSchedulerPriority) {\r\n    PostTaskSchedulerPriority[\"background\"] = \"background\";\r\n    PostTaskSchedulerPriority[\"userBlocking\"] = \"user-blocking\";\r\n    PostTaskSchedulerPriority[\"userVisible\"] = \"user-visible\";\r\n})(PostTaskSchedulerPriority || (PostTaskSchedulerPriority = {}));\r\nconst postTaskScheduler = typeof window !== 'undefined'\r\n    ? window.scheduler || {\r\n        postTask(options) {\r\n            const start = Date.now();\r\n            return new Promise(resolve => {\r\n                setTimeout(function () {\r\n                    console.error('postTask not implemented. Use setTimeout as fallback');\r\n                    resolve();\r\n                }, 1);\r\n            });\r\n        }\r\n    }\r\n    : () => { };\r\nclass PostTaskAction extends Subscription {\r\n    constructor(work) {\r\n        super();\r\n        this.work = work;\r\n    }\r\n    schedule(state, delay) {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        return this._scheduler.schedule(this.work, delay, state);\r\n    }\r\n}\r\nfunction getPostTaskScheduler(priority) {\r\n    return {\r\n        now() {\r\n            return asyncScheduler.now();\r\n        },\r\n        schedule(work, options = {}, state) {\r\n            if (isObject(options) && options.delay) {\r\n                return asyncScheduler.schedule(work, options.delay, state);\r\n            }\r\n            options = Object.assign(Object.assign({}, options), { priority });\r\n            const action = new PostTaskAction(work);\r\n            // weired hack\r\n            action._scheduler = this;\r\n            const promise = postTaskScheduler\r\n                .postTask(() => { }, options)\r\n                .then(() => {\r\n                try {\r\n                    work.call(action, state);\r\n                }\r\n                catch (error) {\r\n                    action.unsubscribe();\r\n                    throw error;\r\n                }\r\n            });\r\n            action.add(() => {\r\n                throw new Error('not implemented');\r\n            });\r\n            return action;\r\n        }\r\n    };\r\n}\n\nconst cancelIdleCallback = typeof window !== 'undefined'\r\n    ? window.cancelIdleCallback ||\r\n        function (idleId) {\r\n            console.warn('Fake cancelIdleCallback used');\r\n            clearTimeout(idleId);\r\n        }\r\n    : () => { };\r\nconst requestIdleCallback = typeof window !== 'undefined'\r\n    ? window.requestIdleCallback ||\r\n        function (cb) {\r\n            console.warn('Fake requestIdleCallback used');\r\n            const start = Date.now();\r\n            return setTimeout(function () {\r\n                cb({\r\n                    didTimeout: false,\r\n                    timeRemaining: function () {\r\n                        return Math.max(0, 50 - (Date.now() - start));\r\n                    }\r\n                });\r\n            }, 1);\r\n        }\r\n    : () => { };\r\nclass IdleAction extends Subscription {\r\n    constructor(work) {\r\n        super();\r\n        this.work = work;\r\n    }\r\n    schedule(state, delay) {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        return idleScheduler.schedule(this.work, delay, state);\r\n    }\r\n}\r\nconst idleScheduler = {\r\n    now() {\r\n        return asyncScheduler.now();\r\n    },\r\n    schedule(work, delay, state) {\r\n        if (delay) {\r\n            return asyncScheduler.schedule(work, delay, state);\r\n        }\r\n        const action = new IdleAction(work);\r\n        const id = requestIdleCallback(() => {\r\n            try {\r\n                work.call(action, state);\r\n            }\r\n            catch (error) {\r\n                action.unsubscribe();\r\n                throw error;\r\n            }\r\n        });\r\n        action.add(() => cancelIdleCallback(id));\r\n        return action;\r\n    }\r\n};\n\nconst ɵ0$1 = subscriber => {\r\n    let i = 0;\r\n    const id = getZoneUnPatchedApi('requestAnimationFrame')(() => {\r\n        subscriber.next(++i);\r\n    });\r\n    return () => {\r\n        getZoneUnPatchedApi('cancelAnimationFrame')(id);\r\n    };\r\n};\r\nconst animationFrameTick = new Observable(ɵ0$1);\r\nconst unpatchedAnimationFrameScheduler = {\r\n    now() {\r\n        return 0;\r\n    },\r\n    schedule(work, options, state) {\r\n        return animationFrameTick.subscribe(() => work(state));\r\n    }\r\n};\n\nvar SchedulingPriority;\r\n(function (SchedulingPriority) {\r\n    SchedulingPriority[\"animationFrame\"] = \"animationFrame\";\r\n    SchedulingPriority[\"Promise\"] = \"Promise\";\r\n    SchedulingPriority[\"idleCallback\"] = \"idleCallback\";\r\n    SchedulingPriority[\"userBlocking\"] = \"userBlocking\";\r\n    SchedulingPriority[\"userVisible\"] = \"userVisible\";\r\n    SchedulingPriority[\"background\"] = \"background\";\r\n    SchedulingPriority[\"setInterval\"] = \"setInterval\";\r\n})(SchedulingPriority || (SchedulingPriority = {}));\n\nconst prioritySchedulerMap = {\r\n    animationFrame: animationFrameScheduler,\r\n    Promise: asapScheduler,\r\n    setInterval: asyncScheduler,\r\n    idleCallback: idleScheduler,\r\n    userBlocking: getPostTaskScheduler(PostTaskSchedulerPriority.userBlocking),\r\n    userVisible: getPostTaskScheduler(PostTaskSchedulerPriority.userVisible),\r\n    background: getPostTaskScheduler(PostTaskSchedulerPriority.background)\r\n};\r\nfunction getScheduler(priority) {\r\n    if (!prioritySchedulerMap.hasOwnProperty(priority)) {\r\n        throw new Error(`priority ${priority} is not present in prioritiesMap`);\r\n    }\r\n    return prioritySchedulerMap[priority];\r\n}\n\nfunction staticCoalesce(work, durationSelector, scope = {}) {\r\n    const coalescingManager = createCoalesceManager(scope);\r\n    if (!coalescingManager.isCoalescing()) {\r\n        coalescingManager.add();\r\n        durationSelector.subscribe(() => {\r\n            tryExecuteWork();\r\n        });\r\n    }\r\n    // =====\r\n    function tryExecuteWork() {\r\n        coalescingManager.remove();\r\n        if (!coalescingManager.isCoalescing()) {\r\n            return work();\r\n        }\r\n    }\r\n}\n\nfunction schedule(work, priority) {\r\n    return getScheduler(priority).schedule(() => work());\r\n}\n\nfunction coalesceAndSchedule(work, priority, scope = {}) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scheduledWork = () => schedule(work, priority);\r\n    staticCoalesce(scheduledWork, durationSelector, scope);\r\n}\n\n/**\r\n * Noop Strategy\r\n *\r\n * This strategy is does nothing. It serves for debugging only\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `noop`      | ❌/❌         | no rendering        | ❌               |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createNoopStrategy() {\r\n    return {\r\n        name: 'noop',\r\n        renderMethod: () => { },\r\n        behavior: o => o,\r\n        scheduleCD: () => { }\r\n    };\r\n}\n\n/**\r\n * Native Strategy\r\n * @description\r\n *\r\n * This strategy mirrors Angular's built-in `async` pipe.\r\n * This means for every emitted value `ChangeDetectorRef#markForCheck` is called.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `native`    | ❌/❌         | mFC / mFC           | ❌               |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createNativeStrategy(config) {\r\n    return {\r\n        name: 'native',\r\n        renderMethod: config.cdRef.markForCheck,\r\n        behavior: o => o,\r\n        scheduleCD: () => {\r\n            config.cdRef.markForCheck();\r\n        }\r\n    };\r\n}\n\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `local`    | ✔/✔ ️        | dC / ɵDC            | ✔ ️ + C/ LV     |\r\n * | `detach`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `postTask` | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `idleCallback` | ❌/✔ ️   | mFC  / ɵMD          | ❌               |\r\n *\r\n */\r\nfunction getLocalStrategies(config) {\r\n    return {\r\n        local: createLocalStrategy(config),\r\n        localCoalesce: createLocalCoalesceStrategy(config),\r\n        localCoalesceAndSchedule: createLocalCoalesceAndScheduleStrategy(config),\r\n        localNative: createLocalNativeStrategy(config),\r\n        detach: createDetachStrategy(config),\r\n        userVisible: createUserVisibleStrategy(config),\r\n        userBlocking: createUserBlockingStrategy(config),\r\n        background: createBackgroundStrategy(config),\r\n        idleCallback: createIdleCallbackStrategy(config)\r\n    };\r\n}\r\nfunction createLocalNativeStrategy(config) {\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe();\r\n    const scheduleCD = () => renderMethod();\r\n    return {\r\n        name: 'localNative',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  Local Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵlocal`    | ✔️/✔️    | dC / dC             | ✔️ + C         |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createLocalStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'local',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\nfunction createLocalCoalesceStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'localCoalesce',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\nfunction createLocalCoalesceAndScheduleStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'localCoalesceAndSchedule',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  Detach Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵdetach`     | ✔️/✔️          | dC / ɵDC            | ✔️ + C/ LV       |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createDetachStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.reattach();\r\n        config.cdRef.detectChanges();\r\n        config.cdRef.detach();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'detach',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  PostTask - Priority UserVisible Strategy\r\n *\r\n */\r\nfunction createUserVisibleStrategy(config) {\r\n    const durationSelector = new Observable(subscriber => {\r\n        from(postTaskScheduler.postTask(() => void 0, {\r\n            priority: PostTaskSchedulerPriority.userVisible,\r\n            delay: 0\r\n        })).subscribe(subscriber);\r\n    });\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.background;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'userVisible',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  PostTask - Priority UserBlocking Strategy\r\n *\r\n */\r\nfunction createUserBlockingStrategy(config) {\r\n    const durationSelector = new Observable(subscriber => {\r\n        from(postTaskScheduler.postTask(() => void 0, {\r\n            priority: PostTaskSchedulerPriority.userVisible,\r\n            delay: 0\r\n        })).subscribe(subscriber);\r\n    });\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.background;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => {\r\n        staticCoalesce(renderMethod, durationSelector, scope);\r\n        // coalesceAndSchedule(renderMethod, priority, scope);\r\n    };\r\n    return {\r\n        name: 'userBlocking',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  PostTask - Priority Background Strategy\r\n *\r\n */\r\nfunction createBackgroundStrategy(config) {\r\n    const durationSelector = new Observable(subscriber => {\r\n        from(postTaskScheduler.postTask(() => void 0, {\r\n            priority: PostTaskSchedulerPriority.userVisible,\r\n            delay: 0\r\n        })).subscribe(subscriber);\r\n    });\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.background;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => {\r\n        staticCoalesce(renderMethod, durationSelector, scope);\r\n        // coalesceAndSchedule(renderMethod, priority, scope);\r\n    };\r\n    return {\r\n        name: 'background',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  IdleCallback Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges is used the coalescing described in `ɵlocal` is implemented here.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵdetach`     | ✔️/✔️          | dC / ɵDC            | ✔️ + C/ LV       |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createIdleCallbackStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.idleCallback;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'idleCallback',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\n\nfunction getGlobalStrategies(config) {\r\n    return {\r\n        global: createGlobalStrategy(config)\r\n    };\r\n}\r\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `global`   | ❌/✔ ️        | mFC  / ɵMD          | ❌               |\r\n *\r\n */\r\n/**\r\n *\r\n * Global Strategy\r\n *\r\n * This strategy is rendering the application root and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing       |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `global`   | ❌/✔️       | mFC / ɵMD           | ❌                |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createGlobalStrategy(config) {\r\n    const renderMethod = () => ɵmarkDirty(config.cdRef.context);\r\n    return {\r\n        name: 'global',\r\n        renderMethod,\r\n        behavior: o => o,\r\n        scheduleCD: () => renderMethod()\r\n    };\r\n}\n\nconst DEFAULT_STRATEGY_NAME = 'local';\r\nfunction getStrategies(config) {\r\n    return Object.assign(Object.assign({ noop: createNoopStrategy(), native: createNativeStrategy(config) }, getGlobalStrategies(config)), getLocalStrategies(config));\r\n}\r\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `noop`      | ❌/❌          | no rendering        | ❌               |\r\n * | `native`    | ❌/❌          | mFC / mFC           | ❌               |\r\n * | `global`    | ❌/✔ ️       | mFC  / ɵMD           | ❌               |\r\n * | `local`     | ✔/✔ ️        | dC / ɵDC            | ✔ ️ + C/ LV     |\r\n * | `ɵglobal`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `ɵlocal`    | ✔/✔ ️       | dC / ɵDC             | ✔ ️ + C/ LV     |\r\n * | `ɵdetach`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n *\r\n */\n\n/**\r\n * @Pipe PushPipe\r\n *\r\n * @description\r\n *\r\n * The `push` pipe serves as a drop-in replacement for the `async` pipe.\r\n * It contains intelligent handling of change detection to enable us\r\n * running in zone-full as well as zone-less mode without any changes to the code.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n *  ```html\r\n *  {{observable$ | async}}\r\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | async\"></component>\r\n * ```\r\n *\r\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\r\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked\r\n *     components.\r\n *\r\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\r\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\r\n *\r\n * `push` pipe solves that problem.\r\n *\r\n * Included Features:\r\n *  - Take observables or promises, retrieve their values and render the value to the template\r\n *  - Handling null and undefined values in a clean unified/structured way\r\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\r\n *  - Distinct same values in a row to increase performance\r\n *  - Coalescing of change detection calls to boost performance\r\n *\r\n * @usageNotes\r\n *\r\n * `push` pipe solves that problem. It can be used like shown here:\r\n * ```html\r\n * {{observable$ | push}}\r\n * <ng-container *ngIf=\"observable$ | push as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | push\"></component>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nlet PushPipe = class PushPipe {\r\n    constructor(cdRef) {\r\n        this.resetObserver = {\r\n            next: () => {\r\n                this.renderedValue = undefined;\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => (this.renderedValue = value)\r\n        };\r\n        this.RenderAware = createRenderAware({\r\n            strategies: getStrategies({ cdRef }),\r\n            updateObserver: this.updateObserver,\r\n            resetObserver: this.resetObserver\r\n        });\r\n        this.subscription = this.RenderAware.subscribe();\r\n    }\r\n    transform(potentialObservable, config) {\r\n        const strategy = config || DEFAULT_STRATEGY_NAME;\r\n        this.RenderAware.nextStrategy(strategy);\r\n        this.RenderAware.nextPotentialObservable(potentialObservable);\r\n        return this.renderedValue;\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n};\nPushPipe.ɵfac = function PushPipe_Factory(t) { return new (t || PushPipe)(ɵngcc0.ɵɵinjectPipeChangeDetectorRef()); };\nPushPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: \"push\", type: PushPipe, pure: false });\r\nPushPipe.ctorParameters = () => [\r\n    { type: ChangeDetectorRef }\r\n];\r\nPushPipe = __decorate([ __metadata(\"design:paramtypes\", [ChangeDetectorRef])\r\n], PushPipe);\n\nconst DECLARATIONS = [PushPipe];\r\nlet PushModule = class PushModule {\r\n};\nPushModule.ɵfac = function PushModule_Factory(t) { return new (t || PushModule)(); };\nPushModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PushModule });\nPushModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[]] });\n\n/**\r\n * @Directive LetDirective\r\n *\r\n * @description\r\n *\r\n * The `*rxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\r\n * It also helps with several internal processing under the hood.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n * ```html\r\n * <ng-container *ngIf=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * <app-number-special [number]=\"n\">\r\n * </app-number-special>\r\n * </ng-container>\r\n *  ```\r\n *\r\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\r\n *\r\n * Included Features:\r\n * - binding is always present. (`*ngIf=\"truthy$\"`)\r\n * - it takes away the multiple usages of the `async` or `push` pipe\r\n * - a unified/structured way of handling null and undefined\r\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or\r\n *   `ChangeDetectorRef.markForCheck`)\r\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or\r\n *   `ɵdetectChanges`)\r\n * - distinct same values in a row (distinctUntilChanged operator),\r\n *\r\n * @usageNotes\r\n *\r\n * The `*rxLet` directive take over several things and makes it more convenient and save to work with streams in the\r\n *   template\r\n * `<ng-container *rxLet=\"observableNumber$ as c\"></ng-container>`\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n *\r\n * <ng-container *rxLet=\"observableNumber$; let n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n * ```\r\n *\r\n * In addition to that it provides us information from the whole observable context.\r\n * We can track the observables:\r\n * - next value\r\n * - error value\r\n * - complete base-state\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\r\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\r\n * </app-number>\r\n * <ng-container *ngIf=\"e\">\r\n * There is an error: {{e}}\r\n * </ng-container>\r\n * <ng-container *ngIf=\"c\">\r\n * Observable completed: {{c}}\r\n * </ng-container>\r\n * </ng-container>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nlet LetDirective = class LetDirective {\r\n    constructor(cdRef, templateRef, viewContainerRef) {\r\n        this.templateRef = templateRef;\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.ViewContext = {\r\n            $implicit: undefined,\r\n            rxLet: undefined,\r\n            $error: false,\r\n            $complete: false\r\n        };\r\n        this.resetObserver = {\r\n            next: () => {\r\n                // if not initialized no need to set undefined\r\n                if (this.embeddedView) {\r\n                    this.ViewContext.$implicit = undefined;\r\n                    this.ViewContext.rxLet = undefined;\r\n                    this.ViewContext.$error = false;\r\n                    this.ViewContext.$complete = false;\r\n                }\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => {\r\n                // to have initial rendering lazy\r\n                if (!this.embeddedView) {\r\n                    this.createEmbeddedView();\r\n                }\r\n                this.ViewContext.$implicit = value;\r\n                this.ViewContext.rxLet = value;\r\n            },\r\n            error: (error) => {\r\n                // to have initial rendering lazy\r\n                if (!this.embeddedView) {\r\n                    this.createEmbeddedView();\r\n                }\r\n                this.ViewContext.$error = true;\r\n            },\r\n            complete: () => {\r\n                // to have initial rendering lazy\r\n                if (!this.embeddedView) {\r\n                    this.createEmbeddedView();\r\n                }\r\n                this.ViewContext.$complete = true;\r\n            }\r\n        };\r\n        this.strategies = getStrategies({ cdRef });\r\n        this.renderAware = createRenderAware({\r\n            strategies: this.strategies,\r\n            resetObserver: this.resetObserver,\r\n            updateObserver: this.updateObserver\r\n        });\r\n        this.renderAware.nextStrategy(DEFAULT_STRATEGY_NAME);\r\n    }\r\n    set rxLet(potentialObservable) {\r\n        this.renderAware.nextPotentialObservable(potentialObservable);\r\n    }\r\n    set strategy(strategy) {\r\n        this.renderAware.nextStrategy(strategy || DEFAULT_STRATEGY_NAME);\r\n    }\r\n    static ngTemplateContextGuard(dir, ctx) {\r\n        return true;\r\n    }\r\n    ngOnInit() {\r\n        this.subscription = this.renderAware.subscribe();\r\n    }\r\n    createEmbeddedView() {\r\n        this.embeddedView = this.viewContainerRef.createEmbeddedView(this.templateRef, this.ViewContext);\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n        this.viewContainerRef.clear();\r\n    }\r\n};\nLetDirective.ɵfac = function LetDirective_Factory(t) { return new (t || LetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };\nLetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LetDirective, selectors: [[\"\", \"rxLet\", \"\"]], inputs: { rxLet: \"rxLet\", strategy: [\"rxLetStrategy\", \"strategy\"] } });\r\nLetDirective.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: TemplateRef },\r\n    { type: ViewContainerRef }\r\n];\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Object),\r\n    __metadata(\"design:paramtypes\", [Object])\r\n], LetDirective.prototype, \"rxLet\", null);\r\n__decorate([\r\n    Input('rxLetStrategy'),\r\n    __metadata(\"design:type\", Object),\r\n    __metadata(\"design:paramtypes\", [Object])\r\n], LetDirective.prototype, \"strategy\", null);\r\nLetDirective = __decorate([ __metadata(\"design:paramtypes\", [ChangeDetectorRef,\r\n        TemplateRef,\r\n        ViewContainerRef])\r\n], LetDirective);\n\nconst EXPORTED_DECLARATIONS = [LetDirective];\r\nlet LetModule = class LetModule {\r\n};\nLetModule.ɵfac = function LetModule_Factory(t) { return new (t || LetModule)(); };\nLetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LetModule });\nLetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n\nconst zonePatchedEvents = [\r\n    'scroll',\r\n    'mousedown',\r\n    'mouseenter',\r\n    'mouseleave',\r\n    'mousemove',\r\n    'mouseout',\r\n    'mouseover',\r\n    'mouseup',\r\n    'load',\r\n    'pointerup',\r\n    'change',\r\n    'blur',\r\n    'focus',\r\n    'click',\r\n    'contextmenu',\r\n    'drag',\r\n    'dragend',\r\n    'dragenter',\r\n    'dragleave',\r\n    'dragover',\r\n    'dragstart',\r\n    'drop',\r\n    'input'\r\n];\n\n/**\r\n * @Directive UnpatchEventsDirective\r\n *\r\n * @description\r\n *\r\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\r\n * of unnecessary renderings through zones `addEventListener` patches.\r\n * It can be used on any element you apply event bindings.\r\n *\r\n * The current way of binding events to the DOM is to use output bindings:\r\n *  ```html\r\n * <button (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\r\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\r\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\r\n *\r\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\r\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\r\n *\r\n * `unpatch` directive solves that problem.\r\n *\r\n * Included Features:\r\n *  - by default un-patch all registered listeners of the host it is applied on\r\n *  - un-patch only a specified set of registered event listeners\r\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\r\n *  - Not interfering with any logic executed by the registered callback\r\n *\r\n * @usageNotes\r\n *\r\n * The `unpatch` directive can be used like shown here:\r\n * ```html\r\n * <button [unoatch] (click)=\"triggerSomeMethod($event)\">click me</button>\r\n * <button [unoatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n// tslint:disable-next-line:directive-selector\r\nlet UnpatchEventsDirective = class UnpatchEventsDirective {\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.subscription = new Subscription();\r\n        this.events$ = new BehaviorSubject(zonePatchedEvents);\r\n    }\r\n    set events(value) {\r\n        if (value && value.length > 0) {\r\n            this.events$.next(value);\r\n        }\r\n        else {\r\n            this.events$.next(zonePatchedEvents);\r\n        }\r\n    }\r\n    reapplyEventListenersZoneUnPatched(events) {\r\n        events.forEach(ev => {\r\n            unpatchEventListener(this.el.nativeElement, ev);\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n    ngAfterViewInit() {\r\n        this.subscription = this.events$\r\n            .pipe(tap(eventList => this.reapplyEventListenersZoneUnPatched(eventList)))\r\n            .subscribe();\r\n    }\r\n};\nUnpatchEventsDirective.ɵfac = function UnpatchEventsDirective_Factory(t) { return new (t || UnpatchEventsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\nUnpatchEventsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UnpatchEventsDirective, selectors: [[\"\", \"unpatch\", \"\"]], inputs: { events: [\"unpatch\", \"events\"] } });\r\nUnpatchEventsDirective.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\n__decorate([\r\n    Input('unpatch'),\r\n    __metadata(\"design:type\", Array),\r\n    __metadata(\"design:paramtypes\", [Array])\r\n], UnpatchEventsDirective.prototype, \"events\", null);\r\nUnpatchEventsDirective = __decorate([ __metadata(\"design:paramtypes\", [ElementRef])\r\n], UnpatchEventsDirective);\n\nconst DECLARATIONS$1 = [UnpatchEventsDirective];\r\nlet UnpatchEventsModule = class UnpatchEventsModule {\r\n};\nUnpatchEventsModule.ɵfac = function UnpatchEventsModule_Factory(t) { return new (t || UnpatchEventsModule)(); };\nUnpatchEventsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: UnpatchEventsModule });\nUnpatchEventsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n\nlet TemplateModule = class TemplateModule {\r\n};\nTemplateModule.ɵfac = function TemplateModule_Factory(t) { return new (t || TemplateModule)(); };\nTemplateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TemplateModule });\nTemplateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [LetModule, PushModule, UnpatchEventsModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PushPipe, [{\n        type: Pipe,\n        args: [{ name: 'push', pure: false }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PushModule, { declarations: [PushPipe], exports: [PushPipe] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PushModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS,\n                imports: [],\n                exports: DECLARATIONS\n            }]\n    }], null, null); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LetDirective, [{\n        type: Directive,\n        args: [{ selector: '[rxLet]' }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, { rxLet: [{\n            type: Input\n        }], strategy: [{\n            type: Input,\n            args: ['rxLetStrategy']\n        }] }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LetModule, { declarations: [LetDirective], exports: [LetDirective] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LetModule, [{\n        type: NgModule,\n        args: [{\n                declarations: EXPORTED_DECLARATIONS,\n                exports: [EXPORTED_DECLARATIONS]\n            }]\n    }], null, null); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UnpatchEventsDirective, [{\n        type: Directive,\n        args: [{ selector: '[unpatch]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { events: [{\n            type: Input,\n            args: ['unpatch']\n        }] }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UnpatchEventsModule, { declarations: [UnpatchEventsDirective], exports: [UnpatchEventsDirective] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UnpatchEventsModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS$1,\n                exports: DECLARATIONS$1\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TemplateModule, { exports: [LetModule, PushModule, UnpatchEventsModule] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TemplateModule, [{\n        type: NgModule,\n        args: [{\n                exports: [LetModule, PushModule, UnpatchEventsModule]\n            }]\n    }], null, null); })();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { LetDirective, LetModule, PushModule, PushPipe, SchedulingPriority, TemplateModule, UnpatchEventsDirective, UnpatchEventsModule, apiZonePatched, coalesceAndSchedule, coalesceWith, createCoalesceManager, createPropertiesWeakMap, createRenderAware, envZonePatched, getGlobalThis, getPostTaskScheduler, getScheduler, getStrategies, getUnpatchedResolvedPromise, getZoneUnPatchedApi, idleScheduler, isNgZone, isNoopNgZone, isViewEngineIvy, nameToStrategy, prioritySchedulerMap, renderChange, schedule, staticCoalesce, toObservableValue, unpatchEventListener, unpatchedAnimationFrameScheduler, unpatchedAsapScheduler, ɵ0, LetModule as ɵa, PushModule as ɵb, UnpatchEventsModule as ɵc };\n\n//# sourceMappingURL=rx-angular-template.js.map","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n"],"sourceRoot":"webpack:///"}