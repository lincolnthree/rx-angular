{"version":3,"sources":["./node_modules/templateAlpha1/__ivy_ngcc__/fesm2015/rx-angular-template.js","./apps/demos/src/app/features/performance/alphas-compare/alpha-1-toggle/alpha-1-toggle.component.ts","./apps/demos/src/app/features/performance/alphas-compare/alpha-1-toggle/alpha-1-toggle.component.html","./apps/demos/src/app/features/performance/alphas-compare/alpha-0-toggle/alpha-0-toggle.component.ts","./apps/demos/src/app/features/performance/alphas-compare/alpha-0-toggle/alpha-0-toggle.component.html","./apps/demos/src/app/features/performance/alphas-compare/alphas-compare.routes.ts","./apps/demos/src/app/features/performance/alphas-compare/alpha-0-toggle/alpha-0-toggle.module.ts","./apps/demos/src/app/features/performance/alphas-compare/alpha-1-toggle/alpha-1-toggle.module.ts","./apps/demos/src/app/features/performance/alphas-compare/alphas-compare.module.ts","./apps/demos/src/app/features/performance/alphas-compare/alphas-compare.component.html","./apps/demos/src/app/features/performance/alphas-compare/alphas-compare.component.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0G;AACyB;AACkC;;AAErK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,2BAA2B,mBAAmB;AAC9C;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,IAAI;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA;AACA;AACA,WAAW,OAAO;AAClB,iBAAiB,iCAAiC;AAClD,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU;AACjC,yCAAyC,iDAAY;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAG,OAAO,gEAAU;AACtD;AACA,YAAY,gEAAU;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,2EAAoB,IAAI,0DAAG;AAClD;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAa;AAC3C;AACA,yCAAyC,2EAAoB,IAAI,gEAAS;AAC1E,UAAU,+CAAE;AACZ,+DAA+D,0DAAG;AAClE,yCAAyC,kDAAa;AACtD,8DAA8D,2EAAoB;AAClF;AACA;AACA;AACA,IAAI,0DAAG;AACP;AACA,mBAAmB,+CAAE;AACrB;AACA;AACA;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,6DAAM,0BAA0B,gEAAS,eAAe,2EAAoB,IAAI,0DAAG,oDAAoD,+DAAQ,wCAAwC,iEAAU;AACrM;AACA,eAAe,0CAAK;AACpB,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iDAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;;AAEb,qCAAqC,+CAAU;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA,8BAA8B,+CAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED,8BAA8B,+CAAU;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;;AAEb,mCAAmC,+CAAU;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED,sCAAsC,+CAAU;AAChD;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA,KAAK;AACL,kBAAkB;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,8BAA8B,iDAAiD;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAc;AACtB;AACA,mFAAmF,gEAAS,gBAAgB,0DAAG,aAAa,0DAAG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAc;AACtB;AACA;AACA,mFAAmF,gEAAS,gBAAgB,0DAAG,aAAa,0DAAG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,+BAA+B,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,mEAAmE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oDAAoD,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mDAAmD,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B,2EAAoC,IAAI;AAClH,iBAAiB,0DAAmB,EAAE,4CAA4C;AAClF;AACA,KAAK,OAAO,+DAAiB;AAC7B;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,kDAAI;AAClB,gBAAgB,4BAA4B;AAC5C,KAAK,gBAAgB,UAAU,OAAO,+DAAwB,EAAE,EAAE,EAAE,QAAQ,EAAE;AAC9E;AACA,KAAK,OAAO,+DAAiB;AAC7B;;AAEA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF,kBAAkB,8DAAuB,EAAE,mBAAmB;AAC9D,kBAAkB,8DAAuB,EAAE,gBAAgB;AAC3D,cAAc,oDAAoD,gEAAyB,cAAc,gDAAgD,EAAE,EAAE;AAC7J,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,sDAAQ;AACtB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,CAAC,+DAAwB,GAAG,+DAAwB,CAAC,yDAAkB,GAAG,+DAAwB,CAAC,8DAAuB,GAAG;AAC3O,oBAAoB,+DAAwB,EAAE,8DAA8D,oJAAoJ,gCAAgC;AAChS;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,yDAAW,EAAE;AACzB,KAAK,OAAO,8DAAgB;AAC5B;AACA;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,yDAAW,EAAE;AACzB,KAAK,OAAO,8DAAgB;AAC5B;AACA;AACA,aAAa,OAAO,mDAAK,EAAE;AAC3B,gBAAgB,OAAO,mDAAK,4BAA4B;AACxD,qBAAqB,OAAO,mDAAK,EAAE;AACnC,kBAAkB,OAAO,mDAAK,EAAE;AAChC,qBAAqB,OAAO,mDAAK,EAAE;AACnC;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,uDAAS;AACvB;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,OAAO,+DAAwB,EAAE,GAAG,OAAO,yDAAkB,EAAE,GAAG,OAAO,8DAAuB,EAAE,EAAE,EAAE,GAAG;AACxI,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA;AACA,gDAAgD,+BAA+B;AAC/E,iBAAiB,8DAAuB,EAAE,kBAAkB;AAC5D,iBAAiB,8DAAuB,GAAG;AAC3C,cAAc,oDAAoD,gEAAyB,aAAa,wDAAwD,EAAE,EAAE;AACpK,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,sDAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAY;AAC5C,2BAA2B,oDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAG;AACrB;AACA;AACA;AACA,0EAA0E,0CAA0C,+DAAwB,CAAC,wDAAiB,GAAG;AACjK,8BAA8B,+DAAwB,EAAE,0EAA0E,gCAAgC,EAAE;AACpK;AACA,KAAK,OAAO,wDAAU;AACtB;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA;AACA,cAAc,OAAO,mDAAK,sBAAsB;AAChD;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,uDAAS;AACvB,gBAAgB,wBAAwB;AACxC,KAAK,gBAAgB,UAAU,OAAO,wDAAiB,EAAE,EAAE,EAAE,GAAG;AAChE,kBAAkB,mDAAK;AACvB;AACA,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA;AACA,oEAAoE,yCAAyC;AAC7G,2BAA2B,8DAAuB,EAAE,4BAA4B;AAChF,2BAA2B,8DAAuB,GAAG;AACrD,cAAc,oDAAoD,gEAAyB,uBAAuB,4EAA4E,EAAE,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","file":"alphas-compare-alphas-compare-module.js","sourcesContent":["import { Observable, Subscription, ReplaySubject, of, EMPTY, from, BehaviorSubject, Subject } from 'rxjs';\nimport { tap, distinctUntilChanged, map, switchMap, filter, finalize, catchError, mergeAll, withLatestFrom } from 'rxjs/operators';\nimport { ɵmarkDirty, ɵdetectChanges, ChangeDetectorRef, Pipe, NgModule, TemplateRef, ViewContainerRef, Directive, Input, ElementRef, Optional } from '@angular/core';\n\n/**\r\n * @description\r\n *\r\n * A fallback for the new `globalThis` reference.\r\n *\r\n *  It should be used to replace `window` due to different environments in:\r\n *  - SSR (Server Side Rendering)\r\n *  - Tests\r\n *  - Browser\r\n *\r\n *  @return {globalThis} - A reference to globalThis. `window` in the Browser.\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\nfunction getGlobalThis() {\r\n    return (window || self || globalThis);\r\n}\n\n/*\r\n * createPropertiesWeakMap\r\n *\r\n * @param getDefaults: (o: O) => P\r\n * Example:\r\n *\r\n * export interface Properties {\r\n *   isCoalescing: boolean;\r\n * }\r\n *\r\n * const obj: object = {\r\n *   foo: 'bar',\r\n *   isCoalescing: 'weakMap version'\r\n * };\r\n *\r\n * const getDefaults = (ctx: object): Properties => ({isCoalescing: false});\r\n * const propsMap = createPropertiesWeakMap<object, Properties>(getDefaults);\r\n *\r\n * console.log('obj before:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props before:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"weakMap version\"}\r\n *\r\n * propsMap.setProps(obj, {isCoalescing: true});\r\n * console.log('obj after:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props after:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"true\"}\r\n * */\r\nfunction createPropertiesWeakMap(getDefaults) {\r\n    const propertyMap = new WeakMap();\r\n    return {\r\n        getProps: getProperties,\r\n        setProps: setProperties\r\n    };\r\n    function getProperties(ctx) {\r\n        const defaults = getDefaults(ctx);\r\n        const propertiesPresent = propertyMap.get(ctx);\r\n        let properties;\r\n        if (propertiesPresent !== undefined) {\r\n            properties = propertiesPresent;\r\n        }\r\n        else {\r\n            properties = {};\r\n            Object.entries(defaults).forEach(([prop, value]) => {\r\n                properties[prop] = hasKey(ctx, prop) ? ctx[prop] : value;\r\n            });\r\n            propertyMap.set(ctx, properties);\r\n        }\r\n        return properties;\r\n    }\r\n    function setProperties(ctx, props) {\r\n        const properties = getProperties(ctx);\r\n        Object.entries(props).forEach(([prop, value]) => {\r\n            properties[prop] = value;\r\n        });\r\n        propertyMap.set(ctx, properties);\r\n        return properties;\r\n    }\r\n    function hasKey(ctx, property) {\r\n        return ctx[property] != null;\r\n    }\r\n}\n\n/**\r\n * envZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks the window object `zone.js` was instantiated.\r\n * If so, the `window` object maintains a property named `Zone`.\r\n *\r\n * Here how Angular checks it: https://github.com/angular/angular/blob/master/packages/core/src/zone/ng_zone.ts#L123\r\n *\r\n * @return {boolean} - true if `zone.js` patched global APIs.\r\n *\r\n */\r\nfunction envZonePatched() {\r\n    return getGlobalThis().Zone !== undefined;\r\n}\r\n/**\r\n * apiZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks if a specific Browser API is patched by `zone.js`.\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @return {boolean} - true if `zone.js` patched the API in question.\r\n *\r\n */\r\nfunction apiZonePatched(name) {\r\n    // if symbol is present, zone patched the API\r\n    return getGlobalThis()['__zone_symbol__' + name] !== undefined;\r\n}\r\nconst zoneDetectionCache = new WeakMap();\r\n/**\r\n * isNgZone\r\n *\r\n * @description\r\n *\r\n * This function takes an instance of a class which implements the NgZone interface and checks if\r\n * its `runOutsideAngular()` function calls `apply()` on the function passed as parameter. This\r\n * means the Angular application that instantiated this service assumes it runs in a ZoneLess\r\n * environment, and therefore it's change detection will not be triggered by zone related logic.\r\n *\r\n * However, keep in mind this does not mean `zone.js` is not present.\r\n * The environment could still run in ZoneFull mode even if Angular turned it off.\r\n * Consider the situation of a Angular element configured for ZoneLess\r\n * environments is used in an Angular application relining on the zone mechanism.\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NgZone`.\r\n * @return {boolean} - true if instance is of type `NgZone`.\r\n *\r\n */\r\nfunction isNgZone(instance) {\r\n    const cachedValue = zoneDetectionCache.get(instance);\r\n    if (cachedValue !== undefined) {\r\n        return cachedValue;\r\n    }\r\n    let calledApply = false;\r\n    function fn() { }\r\n    fn.apply = () => (calledApply = true);\r\n    instance.runOutsideAngular(fn);\r\n    zoneDetectionCache.set(instance, calledApply);\r\n    return calledApply;\r\n}\r\n/**\r\n * isNoopNgZone\r\n *\r\n *@description\r\n *\r\n * This function takes any instance of a class and checks\r\n * if the constructor name is equal to `NoopNgZone`.\r\n *\r\n * For more detailed information read the description of [isNgZone](#isngzone).\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NoopNgZone`.\r\n * @return {boolean} - true if instance is of type `NoopNgZone`.\r\n *\r\n */\r\nfunction isNoopNgZone(instance) {\r\n    return !isNgZone(instance);\r\n}\n\n/** A shared promise instance to cause a delay of one microtask */\r\nlet resolvedPromise = null;\r\nfunction getUnpatchedResolvedPromise() {\r\n    resolvedPromise =\r\n        resolvedPromise ||\r\n            (apiZonePatched('Promise')\r\n                ? getGlobalThis().__zone_symbol__Promise.resolve()\r\n                : Promise.resolve());\r\n    return resolvedPromise;\r\n}\n\n/**\r\n * envRunsIvy\r\n *\r\n * @description\r\n * Determines the used view engine of an Angular project is Ivy or not.\r\n * The check is done based on following table:\r\n * | render       | ViewEngine | ViewEngine | Ivy         | Ivy         |\r\n * | ------------ | ---------- | ---------- | ----------- | ----------- |\r\n * | **mode**     | prod       | dev        | prod        | dev         |\r\n * | **ng**       | present    | present    | `undefined` | present     |\r\n * | **ng.probe** | present    | present    | `undefined` | `undefined` |\r\n *\r\n *  So for Ivy we need to make sure that ng is undefined or,\r\n *  in case of dev environment, ng.probe is undefined.\r\n *\r\n * @return {boolean} - true if the used view engine is Ivy.\r\n *\r\n */\r\nfunction isViewEngineIvy() {\r\n    const ng = getGlobalThis().ng;\r\n    // Is the global ng object is unavailable?\r\n    // ng === undefined in Ivy production mode\r\n    // View Engine has the ng object both in development mode and production mode.\r\n    return (ng === undefined ||\r\n        // in case we are in dev mode in ivy\r\n        // `probe` property is available on ng object we use View Engine.\r\n        ng.probe === undefined);\r\n}\n\n/**\r\n * getZoneUnPatchedApi\r\n *\r\n * @description\r\n *\r\n * This function returns the zone un-patched API for the a specific Browser API.\r\n * If no element is passed the window is used instead\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @param elem {any} - The elem to get un-patched API from.\r\n * @return {Function} - The zone un-patched API in question.\r\n *\r\n */\r\nfunction getZoneUnPatchedApi(name, elem) {\r\n    elem = elem || getGlobalThis();\r\n    return apiZonePatched(name) ? elem['__zone_symbol__' + name] : elem[name];\r\n}\n\nconst coalescingManager = createCoalesceManager();\r\nconst ɵ0 = ctx => ({\r\n    numCoalescingSubscribers: 0\r\n});\r\nconst coalescingContextPropertiesMap = createPropertiesWeakMap(ɵ0);\r\nfunction createCoalesceManager() {\r\n    return {\r\n        remove: removeWork,\r\n        add: addWork,\r\n        isCoalescing\r\n    };\r\n    // Increments the number of subscriptions in a scope e.g. a class instance\r\n    function removeWork(scope = {}) {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers -\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Decrements the number of subscriptions in a scope e.g. a class instance\r\n    function addWork(scope = {}) {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers +\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Checks if anybody else is already coalescing atm\r\n    function isCoalescing(scope = {}) {\r\n        return (coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers >\r\n            0);\r\n    }\r\n}\n\n/**\r\n * @description\r\n * Limits the number of synchronous emitted a value from the source Observable to\r\n * one emitted value per\r\n *   [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats\r\n *   this process for every tick of the browsers event loop.\r\n *\r\n * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.\r\n * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope\r\n *   coalescing.\r\n *\r\n * @param {function(value: T): SubscribableOrPromise} durationSelector - A function\r\n * that receives a value from the source Observable, for computing the silencing\r\n * duration for each source value, returned as an Observable or a Promise.\r\n * It defaults to `requestAnimationFrame` as durationSelector.\r\n * @param {Object} config - A configuration object to define `leading` and `trailing` behavior and the context object.\r\n * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.\r\n * @return {Observable<T>} An Observable that performs the coalesce operation to\r\n * limit the rate of emissions from the source.\r\n *\r\n * @usageNotes\r\n * Emit clicks at a rate of at most one click per second\r\n * ```ts\r\n * import { fromEvent, animationFrames } from 'rxjs';\r\n * import { coalesce } from 'ngRx/component';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(coalesce(ev => animationFrames));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n */\r\nfunction coalesceWith(durationSelector, scope) {\r\n    const _scope = scope || {};\r\n    return source => {\r\n        const o$ = new Observable(observer => {\r\n            const rootSubscription = new Subscription();\r\n            rootSubscription.add(source.subscribe(createInnerObserver(observer, rootSubscription)));\r\n            return rootSubscription;\r\n        });\r\n        return o$;\r\n        function createInnerObserver(outerObserver, rootSubscription) {\r\n            let actionSubscription;\r\n            let latestValue;\r\n            const tryEmitLatestValue = () => {\r\n                coalescingManager.remove(_scope);\r\n                if (!coalescingManager.isCoalescing(_scope)) {\r\n                    outerObserver.next(latestValue);\r\n                }\r\n            };\r\n            return {\r\n                complete: () => {\r\n                    if (actionSubscription) {\r\n                        tryEmitLatestValue();\r\n                    }\r\n                    outerObserver.complete();\r\n                },\r\n                error: error => outerObserver.error(error),\r\n                next: value => {\r\n                    latestValue = value;\r\n                    if (!actionSubscription) {\r\n                        coalescingManager.add(_scope);\r\n                        actionSubscription = durationSelector.subscribe({\r\n                            next: () => {\r\n                                tryEmitLatestValue();\r\n                                actionSubscription = undefined;\r\n                            },\r\n                            complete: () => {\r\n                                if (actionSubscription) {\r\n                                    tryEmitLatestValue();\r\n                                    actionSubscription = undefined;\r\n                                }\r\n                            }\r\n                        });\r\n                        rootSubscription.add(actionSubscription);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}\n\n/**\r\n * Noop Strategy\r\n *\r\n * This strategy is does nothing. It serves for debugging only\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `noop`      | ❌       | ❌             | ❌                | ❌         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createNoopStrategy() {\r\n    return {\r\n        name: 'noop',\r\n        detectChanges: () => { },\r\n        rxScheduleCD: o => o,\r\n        scheduleCD: () => new AbortController()\r\n    };\r\n}\n\n/**\r\n * Native Strategy\r\n * @description\r\n *\r\n * - mFC - `cdRef.markForCheck`\r\n *\r\n * This strategy mirrors Angular's built-in `async` pipe.\r\n * This means for every emitted value `ChangeDetectorRef#markForCheck` is called.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `native`    | ❌       | mFC           | ❌                | ❌         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createNativeStrategy(config) {\r\n    const component = config.cdRef.context;\r\n    return {\r\n        name: 'native',\r\n        detectChanges: () => config.cdRef.markForCheck(),\r\n        rxScheduleCD: o => o.pipe(tap(() => ɵmarkDirty(component))),\r\n        scheduleCD: () => {\r\n            ɵmarkDirty(component);\r\n            return new AbortController();\r\n        }\r\n    };\r\n}\n\nfunction nameToStrategy(strategies) {\r\n    return (o$) => {\r\n        return o$.pipe(distinctUntilChanged(), map((strategy) => {\r\n            const s = strategies[strategy];\r\n            if (!!s) {\r\n                return s;\r\n            }\r\n            throw new Error(`Strategy ${strategy} does not exist.`);\r\n        }));\r\n    };\r\n}\n\n/**\r\n * RenderAware\r\n *\r\n * @description\r\n * This function returns an object that holds all the shared logic for the push pipe and the let directive\r\n * responsible for change detection\r\n * If you extend this class you need to implement how the update of the rendered value happens.\r\n * Also custom behaviour is something you need to implement in the extending class\r\n */\r\nfunction createRenderAware(cfg) {\r\n    const strategyName$ = new ReplaySubject(1);\r\n    let currentStrategy;\r\n    const strategy$ = strategyName$.pipe(distinctUntilChanged(), switchMap(stringOrObservable => typeof stringOrObservable === 'string'\r\n        ? of(stringOrObservable)\r\n        : stringOrObservable), nameToStrategy(cfg.strategies), tap(s => (currentStrategy = s)));\r\n    const observablesFromTemplate$ = new ReplaySubject(1);\r\n    const valuesFromTemplate$ = observablesFromTemplate$.pipe(distinctUntilChanged());\r\n    let firstTemplateObservableChange = true;\r\n    const renderingEffect$ = valuesFromTemplate$.pipe(\r\n    // handle null | undefined assignment and new Observable reset\r\n    map(observable$ => {\r\n        if (observable$ === null) {\r\n            return of(null);\r\n        }\r\n        if (!firstTemplateObservableChange) {\r\n            cfg.resetObserver.next();\r\n            if (observable$ === undefined) {\r\n                return of(undefined);\r\n            }\r\n        }\r\n        firstTemplateObservableChange = false;\r\n        return observable$;\r\n    }), \r\n    // forward only observable values\r\n    filter(o$ => o$ !== undefined), switchMap(o$ => o$.pipe(distinctUntilChanged(), tap(cfg.updateObserver), currentStrategy.rxScheduleCD, finalize(() => currentStrategy.scheduleCD()))), catchError(e => {\r\n        console.error(e);\r\n        return EMPTY;\r\n    }));\r\n    return {\r\n        nextPotentialObservable(value) {\r\n            observablesFromTemplate$.next(value);\r\n        },\r\n        nextStrategy(nextConfig) {\r\n            strategyName$.next(nextConfig);\r\n        },\r\n        activeStrategy$: strategy$,\r\n        subscribe() {\r\n            return new Subscription()\r\n                .add(strategy$.subscribe())\r\n                .add(renderingEffect$.subscribe());\r\n        }\r\n    };\r\n}\n\nfunction staticCoalesce(work, durationSelector, scope = {}, abC = new AbortController()) {\r\n    let sub;\r\n    if (!coalescingManager.isCoalescing(scope)) {\r\n        coalescingManager.add(scope);\r\n        sub = durationSelector.subscribe(() => {\r\n            tryExecuteWork();\r\n        });\r\n        const abortHandler = function () {\r\n            sub.unsubscribe();\r\n            abC.signal.removeEventListener('abort', abortHandler, false);\r\n        };\r\n        abC.signal.addEventListener('abort', abortHandler, false);\r\n    }\r\n    return abC;\r\n    // =====\r\n    function tryExecuteWork() {\r\n        coalescingManager.remove(scope);\r\n        if (!coalescingManager.isCoalescing(scope)) {\r\n            return work();\r\n        }\r\n    }\r\n}\n\nvar PostTaskSchedulerPriority;\r\n(function (PostTaskSchedulerPriority) {\r\n    PostTaskSchedulerPriority[\"background\"] = \"background\";\r\n    PostTaskSchedulerPriority[\"userBlocking\"] = \"user-blocking\";\r\n    PostTaskSchedulerPriority[\"userVisible\"] = \"user-visible\";\r\n})(PostTaskSchedulerPriority || (PostTaskSchedulerPriority = {}));\r\nconst postTaskScheduler = typeof window !== 'undefined'\r\n    ? window.scheduler || {\r\n        postTask(options) {\r\n            const start = Date.now();\r\n            return new Promise(resolve => {\r\n                setTimeout(function () {\r\n                    console.error('postTask not implemented. Use setTimeout as fallback');\r\n                    resolve();\r\n                }, 1);\r\n            });\r\n        }\r\n    }\r\n    : () => { };\n\nconst animationFrameTick = () => new Observable(subscriber => {\r\n    const id = getZoneUnPatchedApi('requestAnimationFrame')(() => {\r\n        subscriber.next(0);\r\n        subscriber.complete();\r\n    });\r\n    return () => {\r\n        getZoneUnPatchedApi('cancelAnimationFrame')(id);\r\n    };\r\n});\n\n// @NOTICE replace logic with 7v handling of promises in RxJS\r\nconst promiseTick = () => new Observable(subscriber => {\r\n    let cancelled = false;\r\n    getUnpatchedResolvedPromise()\r\n        .then(() => {\r\n        if (!cancelled) {\r\n            subscriber.next(0);\r\n            subscriber.complete();\r\n        }\r\n    })\r\n        .catch(e => {\r\n        subscriber.error(e);\r\n    });\r\n    return () => {\r\n        cancelled = true;\r\n        subscriber.complete();\r\n    };\r\n});\n\nconst timeoutTick = () => new Observable(subscriber => {\r\n    const id = window.__zone_symbol__setTimeout(() => {\r\n        subscriber.next(0);\r\n        subscriber.complete();\r\n    });\r\n    return () => {\r\n        window.__zone_symbol__clearTimeout(id);\r\n    };\r\n});\n\nconst cancelIdleCallback = typeof window !== 'undefined'\r\n    ? window.cancelIdleCallback ||\r\n        function (idleId) {\r\n            console.warn('Fake cancelIdleCallback used');\r\n            clearTimeout(idleId);\r\n        }\r\n    : () => { };\r\nconst requestIdleCallback = typeof window !== 'undefined'\r\n    ? window.requestIdleCallback ||\r\n        function (cb) {\r\n            console.warn('Fake requestIdleCallback used');\r\n            const start = Date.now();\r\n            return setTimeout(function () {\r\n                cb({\r\n                    didTimeout: false,\r\n                    timeRemaining: function () {\r\n                        return Math.max(0, 50 - (Date.now() - start));\r\n                    }\r\n                });\r\n            }, 1);\r\n        }\r\n    : () => { };\n\nconst idleCallbackTick = () => new Observable(subscriber => {\r\n    const id = requestIdleCallback(() => {\r\n        subscriber.next(0);\r\n        subscriber.complete();\r\n    });\r\n    return () => cancelIdleCallback(id);\r\n});\n\nconst postTaskTick = (options) => new Observable(subscription => {\r\n    postTaskScheduler\r\n        .postTask(() => { }, options)\r\n        .then(() => {\r\n        subscription.next(0);\r\n        subscription.complete();\r\n    });\r\n    return () => { };\r\n});\n\nconst priorityTickMap = {\r\n    animationFrame: animationFrameTick(),\r\n    Promise: promiseTick(),\r\n    setInterval: timeoutTick(),\r\n    idleCallback: idleCallbackTick(),\r\n    userBlocking: postTaskTick({\r\n        priority: PostTaskSchedulerPriority.userBlocking\r\n    }),\r\n    userVisible: postTaskTick({\r\n        priority: PostTaskSchedulerPriority.userVisible\r\n    }),\r\n    background: postTaskTick({ priority: PostTaskSchedulerPriority.background })\r\n};\n\nfunction staticSchedule(work, priority, abC = new AbortController()) {\r\n    // immediately execute work\r\n    if (priority === false) {\r\n        tryExecuteWork();\r\n        return abC;\r\n    }\r\n    // schedule work\r\n    const sub = priorityTickMap[priority].subscribe(() => tryExecuteWork(), error => console.error(error), \r\n    // on complete abort further executions\r\n    () => abC.abort());\r\n    const abortHandler = function () {\r\n        sub.unsubscribe();\r\n        abC.signal.removeEventListener('abort', abortHandler, false);\r\n    };\r\n    abC.signal.addEventListener('abort', abortHandler, false);\r\n    return abC;\r\n    // execute work and abort further executions\r\n    function tryExecuteWork() {\r\n        if (!abC.signal.aborted) {\r\n            work();\r\n            abC.abort();\r\n        }\r\n    }\r\n}\n\nfunction coalesceAndSchedule(work, priority, scope = {}, abC = new AbortController()) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scheduledWork = () => staticSchedule(work, priority, abC);\r\n    const coalesceAbC = staticCoalesce(scheduledWork, durationSelector, scope, abC);\r\n    const abortHandler = function () {\r\n        coalesceAbC.abort();\r\n        abC.signal.removeEventListener('abort', abortHandler, false);\r\n    };\r\n    abC.signal.addEventListener('abort', abortHandler, false);\r\n    return abC;\r\n}\n\nvar SchedulingPriority;\r\n(function (SchedulingPriority) {\r\n    SchedulingPriority[\"animationFrame\"] = \"animationFrame\";\r\n    SchedulingPriority[\"Promise\"] = \"Promise\";\r\n    SchedulingPriority[\"idleCallback\"] = \"idleCallback\";\r\n    SchedulingPriority[\"userBlocking\"] = \"userBlocking\";\r\n    SchedulingPriority[\"userVisible\"] = \"userVisible\";\r\n    SchedulingPriority[\"background\"] = \"background\";\r\n    SchedulingPriority[\"setInterval\"] = \"setInterval\";\r\n})(SchedulingPriority || (SchedulingPriority = {}));\n\nconst promiseDurationSelector = promiseTick();\r\n/**\r\n * Experimental Local Strategies\r\n *\r\n * - ɵDC - `ɵdetectChanges`\r\n * - C - `Component`\r\n * - det - `cdRef.detach`\r\n * - ret - `cdRef.reattach`\r\n * - Pr - `Promise`\r\n * - aF - `requestAnimationFrame`\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `local`     | ✔        | ɵDC           | C + Pr           | aF         | ❌      |\r\n * | `detach`    | ✔ ️     | ret,ɵDC, det  | C + Pr           | aF         | ❌      |\r\n *\r\n */\r\nfunction getLocalStrategies(config) {\r\n    return {\r\n        local: createLocalStrategy(config),\r\n        detach: createDetachStrategy(config)\r\n    };\r\n}\r\n/**\r\n *  Local Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `local`     | ✔        | ɵDC           | C + Pr           | aF         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createLocalStrategy(config) {\r\n    const component = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const tick = priorityTickMap[priority];\r\n    const renderMethod = () => {\r\n        ɵdetectChanges(component);\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(promiseDurationSelector, component), switchMap(v => tick.pipe(map(() => v))), tap(renderMethod));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, component);\r\n    return {\r\n        name: 'local',\r\n        detectChanges: renderMethod,\r\n        rxScheduleCD: behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  Detach Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `detach`    | ✔ ️     | ret,ɵDC, det  | C + Pr           | aF         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createDetachStrategy(config) {\r\n    const component = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const tick = priorityTickMap[priority];\r\n    const renderMethod = () => {\r\n        config.cdRef.reattach();\r\n        ɵdetectChanges(component);\r\n        config.cdRef.detach();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(promiseDurationSelector, component), switchMap(v => tick.pipe(map(() => v))), tap(renderMethod));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, component);\r\n    return {\r\n        name: 'detach',\r\n        detectChanges: renderMethod,\r\n        rxScheduleCD: behavior,\r\n        scheduleCD\r\n    };\r\n}\n\nfunction getGlobalStrategies(config) {\r\n    return {\r\n        global: createGlobalStrategy(config)\r\n    };\r\n}\r\n/**\r\n * Global Strategies\r\n *\r\n * - ɵMD - `ɵmarkDirty`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `global`     | ✔        | ɵMD           | C + Pr          | ❌         | ❌      |\r\n *\r\n */\r\n/**\r\n *\r\n * Global Strategy\r\n *\r\n * This strategy is rendering the application root and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `global`     | ✔        | ɵMD           | C + Pr          | ❌         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createGlobalStrategy(config) {\r\n    const renderMethod = () => ɵmarkDirty(config.cdRef.context);\r\n    return {\r\n        name: 'global',\r\n        detectChanges: renderMethod,\r\n        rxScheduleCD: o => o,\r\n        scheduleCD: () => {\r\n            renderMethod();\r\n            return new AbortController();\r\n        }\r\n    };\r\n}\n\nconst DEFAULT_STRATEGY_NAME = 'local';\r\nfunction getStrategies(config) {\r\n    return Object.assign(Object.assign({ noop: createNoopStrategy(), native: createNativeStrategy(config) }, getGlobalStrategies(config)), getLocalStrategies(config));\r\n}\r\n/**\r\n * Strategies\r\n *\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - C - `Component`\r\n * - det - `cdRef.detach`\r\n * - ret - `cdRef.reattach`\r\n * - Pr - `Promise`\r\n * - aF - `requestAnimationFrame`\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `noop`      | ❌       | ❌             | ❌               | ❌         | ❌       |\r\n * | `native`    | ❌       | mFC           | ❌                | ❌         | ❌      |\r\n * | `global`    | ✔        | ɵMD           | C + Pr           | ❌         | ❌      |\r\n * | `local`     | ✔        | ɵDC           | C + Pr           | aF         | ❌      |\r\n * | `detach`    | ✔ ️     | ret,ɵDC, det  | C + Pr           | aF         | ❌      |\r\n */\n\nfunction renderChange(cdRef, strategyName) {\r\n    const strategies = getStrategies({ cdRef });\r\n    const strategy = strategies[strategyName];\r\n    return o => o.pipe(strategy.rxScheduleCD);\r\n}\n\n/**\r\n * @Pipe PushPipe\r\n *\r\n * @description\r\n *\r\n * The `push` pipe serves as a drop-in replacement for the `async` pipe.\r\n * It contains intelligent handling of change detection to enable us\r\n * running in zone-full as well as zone-less mode without any changes to the code.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n *  ```html\r\n *  {{observable$ | async}}\r\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | async\"></component>\r\n * ```\r\n *\r\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\r\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked\r\n *     components.\r\n *\r\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\r\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\r\n *\r\n * `push` pipe solves that problem.\r\n *\r\n * Included Features:\r\n *  - Take observables or promises, retrieve their values and render the value to the template\r\n *  - Handling null and undefined values in a clean unified/structured way\r\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\r\n *  - Distinct same values in a row to increase performance\r\n *  - Coalescing of change detection calls to boost performance\r\n *\r\n * @usageNotes\r\n *\r\n * `push` pipe solves that problem. It can be used like shown here:\r\n * ```html\r\n * {{observable$ | push}}\r\n * <ng-container *ngIf=\"observable$ | push as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | push\"></component>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass PushPipe {\r\n    constructor(cdRef) {\r\n        this.resetObserver = {\r\n            next: () => {\r\n                this.renderedValue = undefined;\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => (this.renderedValue = value)\r\n        };\r\n        this.RenderAware = createRenderAware({\r\n            strategies: getStrategies({\r\n                cdRef\r\n            }),\r\n            updateObserver: this.updateObserver,\r\n            resetObserver: this.resetObserver\r\n        });\r\n        this.subscription = this.RenderAware.subscribe();\r\n    }\r\n    transform(potentialObservable, config) {\r\n        const strategy = config || DEFAULT_STRATEGY_NAME;\r\n        this.RenderAware.nextStrategy(strategy);\r\n        this.RenderAware.nextPotentialObservable(potentialObservable);\r\n        return this.renderedValue;\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n}\nPushPipe.ɵfac = function PushPipe_Factory(t) { return new (t || PushPipe)(ɵngcc0.ɵɵinjectPipeChangeDetectorRef()); };\nPushPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: \"push\", type: PushPipe, pure: false });\r\nPushPipe.ctorParameters = () => [\r\n    { type: ChangeDetectorRef }\r\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PushPipe, [{\n        type: Pipe,\n        args: [{ name: 'push', pure: false }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();\r\nPushPipe.ctorParameters = () => [\r\n    { type: ChangeDetectorRef }\r\n];\n\nconst DECLARATIONS = [PushPipe];\r\nclass PushModule {\r\n}\nPushModule.ɵfac = function PushModule_Factory(t) { return new (t || PushModule)(); };\nPushModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PushModule });\nPushModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PushModule, { declarations: [PushPipe], exports: [PushPipe] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PushModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS,\n                imports: [],\n                exports: DECLARATIONS\n            }]\n    }], null, null); })();\n\nclass TemplateManager {\r\n    constructor(viewContainerRef, initialViewContext) {\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.templateCache = new Map();\r\n        this.viewCache = new Map();\r\n        this.viewContext = Object.assign({}, initialViewContext);\r\n    }\r\n    updateViewContext(viewContextSlice) {\r\n        Object.entries(viewContextSlice).forEach(([key, value]) => {\r\n            this.viewContext[key] = value;\r\n        });\r\n    }\r\n    addTemplateRef(name, templateRef) {\r\n        assertTemplate(name, templateRef);\r\n        this.templateCache.set(name, templateRef);\r\n    }\r\n    insertEmbeddedView(name) {\r\n        if (this.templateCache.has(name)) {\r\n            this.viewContainerRef.detach();\r\n            if (this.viewCache.has(name)) {\r\n                this.viewContainerRef.insert(this.viewCache.get(name));\r\n            }\r\n            else {\r\n                const newView = this.viewContainerRef.createEmbeddedView(this.templateCache.get(name), this.viewContext);\r\n                this.viewCache.set(name, newView);\r\n            }\r\n        }\r\n    }\r\n    destroy() {\r\n        this.viewCache.forEach(embeddedView => embeddedView === null || embeddedView === void 0 ? void 0 : embeddedView.destroy());\r\n        this.viewContainerRef.clear();\r\n    }\r\n}\r\nfunction assertTemplate(property, templateRef) {\r\n    const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);\r\n    if (!isTemplateRefOrNull) {\r\n        throw new Error(`${property} must be a TemplateRef, but received something else.`);\r\n    }\r\n    return isTemplateRefOrNull;\r\n}\n\n/**\r\n * @Directive LetDirective\r\n *\r\n * @description\r\n *\r\n * The `*rxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\r\n * It also helps with several internal processing under the hood.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n * ```html\r\n * <ng-container *ngIf=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * <app-number-special [number]=\"n\">\r\n * </app-number-special>\r\n * </ng-container>\r\n *  ```\r\n *\r\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\r\n *\r\n * Included Features:\r\n * - binding is always present. (`*ngIf=\"truthy$\"`)\r\n * - it takes away the multiple usages of the `async` or `push` pipe\r\n * - a unified/structured way of handling null and undefined\r\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or\r\n *   `ChangeDetectorRef.markForCheck`)\r\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or\r\n *   `ɵdetectChanges`)\r\n * - distinct same values in a row (distinctUntilChanged operator),\r\n *\r\n * @usageNotes\r\n *\r\n * The `*rxLet` directive take over several things and makes it more convenient and save to work with streams in the\r\n *   template\r\n * `<ng-container *rxLet=\"observableNumber$ as c\"></ng-container>`\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n *\r\n * <ng-container *rxLet=\"observableNumber$; let n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n * ```\r\n *\r\n * In addition to that it provides us information from the whole observable context.\r\n * We can track the observables:\r\n * - next value\r\n * - error value\r\n * - complete base-state\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\r\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\r\n * </app-number>\r\n * <ng-container *ngIf=\"e\">\r\n * There is an error: {{e}}\r\n * </ng-container>\r\n * <ng-container *ngIf=\"c\">\r\n * Observable completed: {{c}}\r\n * </ng-container>\r\n * </ng-container>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass LetDirective {\r\n    constructor(cdRef, nextTemplateRef, viewContainerRef) {\r\n        this.nextTemplateRef = nextTemplateRef;\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.resetObserver = {\r\n            next: () => {\r\n                this.templateManager.updateViewContext({\r\n                    $implicit: undefined,\r\n                    rxLet: undefined,\r\n                    $error: false,\r\n                    $complete: false\r\n                });\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => {\r\n                this.templateManager.insertEmbeddedView('rxNext');\r\n                this.templateManager.updateViewContext({\r\n                    $implicit: value,\r\n                    rxLet: value\r\n                });\r\n            },\r\n            error: (error) => {\r\n                // fallback to rxNext when there's no template for rxError\r\n                this.templateManager.insertEmbeddedView('rxNext');\r\n                this.templateManager.insertEmbeddedView('rxError');\r\n                this.templateManager.updateViewContext({\r\n                    $error: true\r\n                });\r\n            },\r\n            complete: () => {\r\n                // fallback to rxNext when there's no template for rxComplete\r\n                this.templateManager.insertEmbeddedView('rxNext');\r\n                this.templateManager.insertEmbeddedView('rxComplete');\r\n                this.templateManager.updateViewContext({\r\n                    $complete: true\r\n                });\r\n            }\r\n        };\r\n        this.strategies = getStrategies({ cdRef });\r\n        this.templateManager = new TemplateManager(this.viewContainerRef, {\r\n            $implicit: undefined,\r\n            rxLet: undefined,\r\n            $error: false,\r\n            $complete: false\r\n        });\r\n        this.renderAware = createRenderAware({\r\n            strategies: this.strategies,\r\n            resetObserver: this.resetObserver,\r\n            updateObserver: this.updateObserver\r\n        });\r\n        this.renderAware.nextStrategy(DEFAULT_STRATEGY_NAME);\r\n    }\r\n    set rxLet(potentialObservable) {\r\n        this.renderAware.nextPotentialObservable(potentialObservable);\r\n    }\r\n    set strategy(strategy) {\r\n        this.renderAware.nextStrategy(strategy || DEFAULT_STRATEGY_NAME);\r\n    }\r\n    set rxLetComplete(templateRef) {\r\n        this.templateManager.addTemplateRef('rxComplete', templateRef);\r\n    }\r\n    set rxLetError(templateRef) {\r\n        this.templateManager.addTemplateRef('rxError', templateRef);\r\n    }\r\n    set rxLetSuspense(templateRef) {\r\n        this.templateManager.addTemplateRef('rxSuspense', templateRef);\r\n    }\r\n    static ngTemplateContextGuard(dir, ctx) {\r\n        return true;\r\n    }\r\n    ngOnInit() {\r\n        this.templateManager.insertEmbeddedView('rxSuspense');\r\n        this.templateManager.addTemplateRef('rxNext', this.nextTemplateRef);\r\n        this.subscription = this.renderAware.subscribe();\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n        this.templateManager.destroy();\r\n    }\r\n}\nLetDirective.ɵfac = function LetDirective_Factory(t) { return new (t || LetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };\nLetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LetDirective, selectors: [[\"\", \"rxLet\", \"\"]], inputs: { rxLet: \"rxLet\", strategy: [\"rxLetStrategy\", \"strategy\"], rxLetComplete: \"rxLetComplete\", rxLetError: \"rxLetError\", rxLetSuspense: \"rxLetSuspense\" }, exportAs: [\"renderNotifier\"] });\r\nLetDirective.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: TemplateRef },\r\n    { type: ViewContainerRef }\r\n];\r\nLetDirective.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: TemplateRef },\r\n    { type: ViewContainerRef }\r\n];\r\nLetDirective.propDecorators = {\r\n    rxLet: [{ type: Input }],\r\n    strategy: [{ type: Input, args: ['rxLetStrategy',] }],\r\n    rxLetComplete: [{ type: Input }],\r\n    rxLetError: [{ type: Input }],\r\n    rxLetSuspense: [{ type: Input }]\r\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LetDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[rxLet]',\n                exportAs: 'renderNotifier'\n            }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, { rxLet: [{\n            type: Input\n        }], strategy: [{\n            type: Input,\n            args: ['rxLetStrategy']\n        }], rxLetComplete: [{\n            type: Input\n        }], rxLetError: [{\n            type: Input\n        }], rxLetSuspense: [{\n            type: Input\n        }] }); })();\n\nconst EXPORTED_DECLARATIONS = [LetDirective];\r\nclass LetModule {\r\n}\nLetModule.ɵfac = function LetModule_Factory(t) { return new (t || LetModule)(); };\nLetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LetModule });\nLetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LetModule, { declarations: [LetDirective], exports: [LetDirective] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LetModule, [{\n        type: NgModule,\n        args: [{\n                declarations: EXPORTED_DECLARATIONS,\n                exports: [EXPORTED_DECLARATIONS]\n            }]\n    }], null, null); })();\n\nconst zonePatchedEvents = [\r\n    'scroll',\r\n    'mousedown',\r\n    'mouseenter',\r\n    'mouseleave',\r\n    'mousemove',\r\n    'mouseout',\r\n    'mouseover',\r\n    'mouseup',\r\n    'load',\r\n    'pointerup',\r\n    'change',\r\n    'blur',\r\n    'focus',\r\n    'click',\r\n    'contextmenu',\r\n    'drag',\r\n    'dragend',\r\n    'dragenter',\r\n    'dragleave',\r\n    'dragover',\r\n    'dragstart',\r\n    'drop',\r\n    'input'\r\n];\n\n/**\r\n *\r\n * @description\r\n *\r\n * This function takes an elem and event and re-applies the listeners from the passed event to the\r\n * passed element with the zone un-patched version of it.\r\n *\r\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\r\n * @param event {string} - The name of the event from which to re-apply the listeners.\r\n *\r\n * @returns void\r\n */\r\nfunction unpatchEventListener(elem, event) {\r\n    const eventListeners = elem.eventListeners(event);\r\n    // Return if no event listeners are present\r\n    if (!eventListeners) {\r\n        return;\r\n    }\r\n    const addEventListener = getZoneUnPatchedApi('addEventListener', elem).bind(elem);\r\n    eventListeners.forEach(listener => {\r\n        // Remove and reapply listeners with patched API\r\n        elem.removeEventListener(event, listener);\r\n        // Reapply listeners with un-patched API\r\n        addEventListener(event, listener);\r\n    });\r\n}\r\n/**\r\n * @Directive UnpatchEventsDirective\r\n *\r\n * @description\r\n *\r\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\r\n * of unnecessary renderings through zones `addEventListener` patches.\r\n * It can be used on any element you apply event bindings.\r\n *\r\n * The current way of binding events to the DOM is to use output bindings:\r\n *  ```html\r\n * <button (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\r\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\r\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\r\n *\r\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\r\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\r\n *\r\n * `unpatch` directive solves that problem.\r\n *\r\n * Included Features:\r\n *  - by default un-patch all registered listeners of the host it is applied on\r\n *  - un-patch only a specified set of registered event listeners\r\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\r\n *  - Not interfering with any logic executed by the registered callback\r\n *\r\n * @usageNotes\r\n *\r\n * The `unpatch` directive can be used like shown here:\r\n * ```html\r\n * <button [unoatch] (click)=\"triggerSomeMethod($event)\">click me</button>\r\n * <button [unoatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n// tslint:disable-next-line:directive-selector\r\nclass UnpatchEventsDirective {\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.subscription = new Subscription();\r\n        this.events$ = new BehaviorSubject(zonePatchedEvents);\r\n    }\r\n    set events(value) {\r\n        if (value && value.length > 0) {\r\n            this.events$.next(value);\r\n        }\r\n        else {\r\n            this.events$.next(zonePatchedEvents);\r\n        }\r\n    }\r\n    reapplyEventListenersZoneUnPatched(events) {\r\n        events.forEach(ev => {\r\n            unpatchEventListener(this.el.nativeElement, ev);\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n    ngAfterViewInit() {\r\n        this.subscription = this.events$\r\n            .pipe(tap(eventList => this.reapplyEventListenersZoneUnPatched(eventList)))\r\n            .subscribe();\r\n    }\r\n}\nUnpatchEventsDirective.ɵfac = function UnpatchEventsDirective_Factory(t) { return new (t || UnpatchEventsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\nUnpatchEventsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UnpatchEventsDirective, selectors: [[\"\", \"unpatch\", \"\"]], inputs: { events: [\"unpatch\", \"events\"] } });\r\nUnpatchEventsDirective.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\nUnpatchEventsDirective.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\nUnpatchEventsDirective.propDecorators = {\r\n    events: [{ type: Input, args: ['unpatch',] }]\r\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UnpatchEventsDirective, [{\n        type: Directive,\n        args: [{ selector: '[unpatch]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { events: [{\n            type: Input,\n            args: ['unpatch']\n        }] }); })();\n\nconst DECLARATIONS$1 = [UnpatchEventsDirective];\r\nclass UnpatchEventsModule {\r\n}\nUnpatchEventsModule.ɵfac = function UnpatchEventsModule_Factory(t) { return new (t || UnpatchEventsModule)(); };\nUnpatchEventsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: UnpatchEventsModule });\nUnpatchEventsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UnpatchEventsModule, { declarations: [UnpatchEventsDirective], exports: [UnpatchEventsDirective] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UnpatchEventsModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS$1,\n                exports: DECLARATIONS$1\n            }]\n    }], null, null); })();\n\n/**\r\n *\r\n * @description\r\n *\r\n * This function takes an elem and event and re-applies the listeners from the passed event to the\r\n * passed element with the zone un-patched version of it.\r\n *\r\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\r\n * @param event {string} - The name of the event from which to re-apply the listeners.\r\n *\r\n * @returns void\r\n */\r\nfunction unpatchEventListener$1(elem, event) {\r\n    const eventListeners = elem.eventListeners(event);\r\n    // Return if no event listeners are present\r\n    if (!eventListeners) {\r\n        return;\r\n    }\r\n    const addEventListener = getZoneUnPatchedApi('addEventListener', elem).bind(elem);\r\n    eventListeners.forEach(listener => {\r\n        // Remove and reapply listeners with patched API\r\n        elem.removeEventListener(event, listener);\r\n        // Reapply listeners with un-patched API\r\n        addEventListener(event, listener);\r\n    });\r\n}\r\nfunction intersectionObserver(options) {\r\n    const subject = new Subject();\r\n    const observer = observerSupported()\r\n        ? new IntersectionObserver(entries => {\r\n            entries.forEach(entry => subject.next(entry));\r\n        }, options)\r\n        : null;\r\n    const entries$ = new Observable(subscriber => {\r\n        subject.subscribe(subscriber);\r\n        return () => {\r\n            if (observer) {\r\n                observer.disconnect();\r\n            }\r\n        };\r\n    });\r\n    return {\r\n        entries$,\r\n        observe: observer.observe,\r\n        unobserve: observer.unobserve\r\n    };\r\n}\r\nconst observerSupported = () => typeof window !== 'undefined'\r\n    ? !!window.IntersectionObserver\r\n    : false;\r\nconst ɵ0$1 = observerSupported;\r\nclass ViewportPrioDirective {\r\n    constructor(el, letDirective) {\r\n        this.el = el;\r\n        this.letDirective = letDirective;\r\n        this.entriesSubject = new Subject();\r\n        this.entries$ = this.entriesSubject.pipe(mergeAll());\r\n        this._viewportPrio = 'noop';\r\n        this.observer = observerSupported()\r\n            ? new IntersectionObserver(entries => this.entriesSubject.next(entries), {\r\n                threshold: 0\r\n            })\r\n            : null;\r\n        this.visibilityEvents$ = this.entries$.pipe(map(entry => {\r\n            if (entry.intersectionRatio > 0) {\r\n                return 'visible';\r\n            }\r\n            else {\r\n                return 'invisible';\r\n            }\r\n        }));\r\n    }\r\n    set viewportPrio(prio) {\r\n        if (prio) {\r\n            this._viewportPrio = prio || 'noop';\r\n        }\r\n    }\r\n    ngOnInit() {\r\n        const letStrategyName$ = this.letDirective.renderAware.activeStrategy$.pipe(map(s => s.name), filter(name => name !== this._viewportPrio));\r\n        this.observer.observe(this.el.nativeElement);\r\n        this.visibilityEvents$\r\n            .pipe(withLatestFrom(letStrategyName$), map(([visibility, strategyName]) => visibility === 'visible' ? strategyName : this._viewportPrio))\r\n            .subscribe(strategyName => {\r\n            this.letDirective.strategy = strategyName;\r\n            // render actual state on viewport enter\r\n            this.letDirective.strategies[strategyName].scheduleCD();\r\n            //\r\n            this.el.nativeElement.classList.add(strategyName);\r\n        });\r\n    }\r\n}\nViewportPrioDirective.ɵfac = function ViewportPrioDirective_Factory(t) { return new (t || ViewportPrioDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(LetDirective, 8)); };\nViewportPrioDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ViewportPrioDirective, selectors: [[\"\", \"viewport-prio\", \"\"]], inputs: { viewportPrio: [\"viewport-prio\", \"viewportPrio\"] } });\r\nViewportPrioDirective.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: LetDirective, decorators: [{ type: Optional }] }\r\n];\r\nViewportPrioDirective.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: LetDirective, decorators: [{ type: Optional }] }\r\n];\r\nViewportPrioDirective.propDecorators = {\r\n    viewportPrio: [{ type: Input, args: ['viewport-prio',] }]\r\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ViewportPrioDirective, [{\n        type: Directive,\n        args: [{\n                // tslint:disable-next-line:directive-selector\n                selector: '[viewport-prio]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: LetDirective, decorators: [{\n                type: Optional\n            }] }]; }, { viewportPrio: [{\n            type: Input,\n            args: ['viewport-prio']\n        }] }); })();\n\nconst DECLARATIONS$2 = [ViewportPrioDirective];\r\nclass ViewportPrioModule {\r\n}\nViewportPrioModule.ɵfac = function ViewportPrioModule_Factory(t) { return new (t || ViewportPrioModule)(); };\nViewportPrioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ViewportPrioModule });\nViewportPrioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ViewportPrioModule, { declarations: [ViewportPrioDirective], exports: [ViewportPrioDirective] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ViewportPrioModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS$2,\n                exports: DECLARATIONS$2\n            }]\n    }], null, null); })();\n\nclass TemplateModule {\r\n}\nTemplateModule.ɵfac = function TemplateModule_Factory(t) { return new (t || TemplateModule)(); };\nTemplateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TemplateModule });\nTemplateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [LetModule, PushModule, UnpatchEventsModule, ViewportPrioModule] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TemplateModule, { exports: [LetModule, PushModule, UnpatchEventsModule, ViewportPrioModule] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TemplateModule, [{\n        type: NgModule,\n        args: [{\n                exports: [LetModule, PushModule, UnpatchEventsModule, ViewportPrioModule]\n            }]\n    }], null, null); })();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { LetDirective, LetModule, PushModule, PushPipe, SchedulingPriority, TemplateModule, UnpatchEventsDirective, UnpatchEventsModule, ViewportPrioDirective, ViewportPrioModule, getStrategies, getZoneUnPatchedApi, isNgZone, isViewEngineIvy, priorityTickMap };\n\n//# sourceMappingURL=rx-angular-template.js.map","import { AfterViewInit, Component, Input } from '@angular/core';\nimport { tap, take, finalize } from 'rxjs/operators';\nimport { BehaviorSubject, Subject, timer } from 'rxjs';\nimport { environment } from '../../../../../environments/environment';\n\n@Component({\n  selector: 'rxa-alpha1',\n  templateUrl: './alpha-1-toggle.component.html',\n  changeDetection: environment.changeDetection,\n})\nexport class Alpha1ToggleComponent implements AfterViewInit {\n  private letEmitted = false;\n  @Input() type: 'rxLet' | 'push';\n  @Input() auto: boolean;\n\n  pushLoading$ = new BehaviorSubject<boolean>(true);\n  letLoading$ = new Subject<boolean>();\n  done$ = new BehaviorSubject<boolean>(false);\n\n  process$ = timer(800, 800);\n\n  constructor() {}\n\n  ngAfterViewInit() {\n    if (this.auto) {\n      this.process$\n        .pipe(\n          tap(() =>\n            this.type === 'push' ? this.togglePush() : this.toggleLet()\n          ),\n          take(10),\n          finalize(() => {\n            this.done$.next(true);\n          })\n        )\n        .subscribe();\n    }\n  }\n\n  toggleList() {\n    this.type === 'push' ? this.togglePush() : this.toggleLet();\n  }\n\n  togglePush() {\n    this.pushLoading$.next(!this.pushLoading$.getValue());\n  }\n\n  toggleLet() {\n    if (!this.letEmitted) {\n      this.letEmitted = true;\n      return this.letLoading$.next(true);\n    }\n\n    this.letLoading$ = new Subject();\n    this.letEmitted = false;\n  }\n}\n","<div class=\"col-sm-12 col-md-6\">\n  <ng-container *ngIf=\"auto\">\n    <p>List of 2000 elements will be toggled 10 times</p>\n  </ng-container>\n  <ng-container *ngIf=\"!auto\">\n    <button color=\"secondary\" (click)=\"toggleList()\">Reset</button>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'push'\">\n    <p *ngIf=\"pushLoading$ | push; else pushContent\">Loading...</p>\n    <ng-template #pushContent>\n      <rxa-rendering-work [factor]=\"20\"></rxa-rendering-work>\n    </ng-template>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'rxLet'\">\n    <ng-container *rxLet=\"letLoading$; let letLoading; suspense: suspenseTpl\">\n      <rxa-rendering-work [factor]=\"20\"></rxa-rendering-work>\n    </ng-container>\n    <ng-template #suspenseTpl> <p>Loading...</p> </ng-template>\n  </ng-container>\n\n  <p *ngIf=\"done$ | push\">Done</p>\n</div>\n","import { AfterViewInit, Component, Input } from '@angular/core';\nimport { tap, take, finalize } from 'rxjs/operators';\nimport { BehaviorSubject, Subject, timer } from 'rxjs';\nimport { environment } from '../../../../../environments/environment';\n\n@Component({\n  selector: 'rxa-alpha0',\n  templateUrl: './alpha-0-toggle.component.html',\n  changeDetection: environment.changeDetection,\n})\nexport class Alpha0ToggleComponent implements AfterViewInit {\n  @Input() type: 'rxLet' | 'push';\n  @Input() auto: boolean;\n\n  pushLoading$ = new BehaviorSubject<boolean>(true);\n  letLoading$ = new BehaviorSubject<boolean>(true);\n  done$ = new BehaviorSubject<boolean>(false);\n\n  process$ = timer(800, 1000);\n\n  constructor() {}\n\n  ngAfterViewInit() {\n    if (this.auto) {\n      this.process$\n        .pipe(\n          tap(() =>\n            this.type === 'push' ? this.togglePush() : this.toggleLet()\n          ),\n          take(10),\n          finalize(() => {\n            this.done$.next(true);\n          })\n        )\n        .subscribe();\n    }\n  }\n\n  toggleList() {\n    this.type === 'push' ? this.togglePush() : this.toggleLet();\n  }\n\n  togglePush() {\n    this.pushLoading$.next(!this.pushLoading$.getValue());\n  }\n\n  toggleLet() {\n    this.letLoading$.next(!this.letLoading$.getValue());\n  }\n}\n","<div class=\"col-sm-12 col-md-6\">\n  <ng-container *ngIf=\"auto\">\n    <p>List of 2000 elements will be toggled 10 times</p>\n  </ng-container>\n  <ng-container *ngIf=\"!auto\">\n    <button [unpatch] color=\"secondary\" (click)=\"toggleList()\">Toggle</button>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'push'\">\n    <p *ngIf=\"pushLoading$ | push; else pushContent\">Loading...</p>\n    <ng-template #pushContent>\n      <rxa-rendering-work [factor]=\"20\"></rxa-rendering-work>\n    </ng-template>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'rxLet'\">\n    <ng-container *rxLet=\"letLoading$; let letLoading\">\n      <rxa-rendering-work\n        *ngIf=\"!letLoading\"\n        [factor]=\"20\"\n      ></rxa-rendering-work>\n      <p *ngIf=\"letLoading\">Loading...</p>\n    </ng-container>\n  </ng-container>\n  <p *ngIf=\"done$ | push\">Done</p>\n</div>\n","import { AlphasCompareComponent } from './alphas-compare.component';\n\nexport const ROUTES = [\n  {\n    path: '',\n    redirectTo: 'alphas-compare',\n  },\n  {\n    path: 'list-toggle',\n    component: AlphasCompareComponent,\n  },\n];\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { TemplateModule } from 'templateAlpha0';\nimport { Alpha0ToggleComponent } from './alpha-0-toggle.component';\nimport { RenderingWorkModule } from '../../../../shared/debug-helper/rendering-work/rendering-work.module';\n\n@NgModule({\n  declarations: [Alpha0ToggleComponent],\n  imports: [CommonModule, TemplateModule, RenderingWorkModule],\n  exports: [Alpha0ToggleComponent],\n})\nexport class Alpha0ToggleModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { LetModule, PushModule } from 'templateAlpha1';\nimport { Alpha1ToggleComponent } from './alpha-1-toggle.component';\nimport { RenderingWorkModule } from '../../../../shared/debug-helper/rendering-work/rendering-work.module';\n\n@NgModule({\n  declarations: [Alpha1ToggleComponent],\n  imports: [CommonModule, LetModule, PushModule, RenderingWorkModule],\n  exports: [Alpha1ToggleComponent],\n})\nexport class Alpha1ToggleModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RenderingWorkModule } from '../../../shared/debug-helper/rendering-work/rendering-work.module';\nimport { RouterModule } from '@angular/router';\nimport { MatButtonModule } from '@angular/material/button';\nimport { AlphasCompareComponent } from './alphas-compare.component';\nimport { ROUTES as ALPHAS_COMPARE_ROUTES } from './alphas-compare.routes';\nimport { Alpha0ToggleModule } from './alpha-0-toggle/alpha-0-toggle.module';\nimport { Alpha1ToggleModule } from './alpha-1-toggle/alpha-1-toggle.module';\nimport { UnpatchEventsModule } from 'templateAlpha1';\n\n@NgModule({\n  declarations: [AlphasCompareComponent],\n  imports: [\n    CommonModule,\n    RenderingWorkModule,\n    MatButtonModule,\n    RouterModule.forChild(ALPHAS_COMPARE_ROUTES),\n    Alpha0ToggleModule,\n    Alpha1ToggleModule,\n    UnpatchEventsModule\n  ]\n})\nexport class AlphasCompareModule {}\n","<h1>Alpha 0 vs Beta 0 (To enable Alpha 1 check alpha-1-toggle.module)</h1>\n<div class=\"row w-100\">\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle0PushAutoTest()\">\n        Run Auto test for Push pipe in Alpha 0\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button [unpatch] color=\"secondary\" (click)=\"toggle0Push()\">\n        Open Manual test for Push pipe in Alpha 0\n      </button>\n    </div>\n    <rxa-alpha0\n      *ngIf=\"show0PushAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'push'\"\n    ></rxa-alpha0>\n    <rxa-alpha0 *ngIf=\"show0Push\" [auto]=\"false\" [type]=\"'push'\"></rxa-alpha0>\n  </div>\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle0LetAutoTest()\">\n        Run Auto test for Let in Alpha 0\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"secondary\" (click)=\"toggle0Let()\">\n        Open Manual test for Let in Alpha 0\n      </button>\n    </div>\n    <rxa-alpha0\n      *ngIf=\"show0LetAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'rxLet'\"\n    ></rxa-alpha0>\n    <rxa-alpha0 *ngIf=\"show0Let\" [auto]=\"false\" [type]=\"'rxLet'\"></rxa-alpha0>\n  </div>\n\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle1PushAutoTest()\">\n        Run Auto test for Push in Alpha 1\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"secondary\" (click)=\"toggle1Push()\">\n        Open Manual test for Push pipe in Alpha 1\n      </button>\n    </div>\n    <rxa-alpha1\n      *ngIf=\"show1PushAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'push'\"\n    ></rxa-alpha1>\n    <rxa-alpha1 *ngIf=\"show1Push\" [auto]=\"false\" [type]=\"'push'\"></rxa-alpha1>\n  </div>\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle1LetAutoTest()\">\n        Run Auto test for Let in Alpha 1\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"secondary\" (click)=\"toggle1Let()\">\n        Open Manual test for Let in Alpha 1\n      </button>\n    </div>\n    <rxa-alpha1\n      *ngIf=\"show1LetAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'rxLet'\"\n    ></rxa-alpha1>\n    <rxa-alpha1 *ngIf=\"show1Let\" [auto]=\"false\" [type]=\"'rxLet'\"></rxa-alpha1>\n  </div>\n</div>\n","import { Component } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { environment } from '../../../../environments/environment';\n\n@Component({\n  selector: 'rxa-alphas-compare',\n  templateUrl: './alphas-compare.component.html',\n  changeDetection: environment.changeDetection,\n})\nexport class AlphasCompareComponent {\n  show0PushAutoTest = false;\n  show0Push = false;\n  show0LetAutoTest = false;\n  show0Let = false;\n  show1PushAutoTest = false;\n  show1Push = false;\n  show1LetAutoTest = false;\n  show1Let = false;\n\n  toggle0Push() {\n    this.show0Push = !this.show0Push;\n  }\n  toggle0PushAutoTest() {\n    this.show0PushAutoTest = !this.show0PushAutoTest;\n  }\n  toggle0Let() {\n    this.show0Let = !this.show0Let;\n  }\n  toggle0LetAutoTest() {\n    this.show0LetAutoTest = !this.show0LetAutoTest;\n  }\n\n  toggle1Push() {\n    this.show1Push = !this.show1Push;\n  }\n  toggle1PushAutoTest() {\n    this.show1PushAutoTest = !this.show1PushAutoTest;\n  }\n\n  toggle1Let() {\n    this.show1Let = !this.show1Let;\n  }\n  toggle1LetAutoTest() {\n    this.show1LetAutoTest = !this.show1LetAutoTest;\n  }\n}\n"],"sourceRoot":"webpack:///"}